<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>静态Enity AOI管理</title>
      <link href="/2023/01/15/%E9%9D%99%E6%80%81Enity%20AOI/"/>
      <url>/2023/01/15/%E9%9D%99%E6%80%81Enity%20AOI/</url>
      
        <content type="html"><![CDATA[<p>这里说的静态Entity指的是位置确定的物体，可以在玩家靠近时加载生成，玩家离开时销毁Entity。<br>为了把性能消耗降到最低，同时不影响玩家的游戏体验，就只会向玩家生成并感兴趣的区域的静态Entity，也就是AOI进行广播。<br>下面介绍的网格法AOI，以一个100*100的地图为例，每10米划分一个网格，就能将整个地图映射到x<del>(0, 1,…,10)和y</del>(0, 1,…,10)的坐标上，游戏运行时仅需要向玩家生成这个坐标附近的网格Entity（AOI范围内）即可，对于玩家AOI范围外的Entity进行销毁。示意图如下，黄色部分是AOI范围内<br><img src="https://github.com/nevermorec/Photo-store/blob/master/AI/13.png?raw=true" alt="image"></p><h2 id="AOI-Entity"><a href="#AOI-Entity" class="headerlink" title="AOI Entity"></a>AOI Entity</h2><p>AOI Entity 是所以静态Enity类的抽象类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AOIEntity</span><br><span class="line">&#123;</span><br><span class="line">    public string key;</span><br><span class="line"></span><br><span class="line">    public bool visiable = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StaticAOIManager"><a href="#StaticAOIManager" class="headerlink" title="StaticAOIManager"></a>StaticAOIManager</h2><p>StaticAOIManager是静态Entity的单例类，下面介绍其中的关键方法，和属性。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Dictionary&lt;string, Action&lt;AOIEntity&gt;&gt; _onSpawnDict = new Dictionary&lt;string,Action&lt;AOIEntity&gt;&gt;();</span><br><span class="line"></span><br><span class="line">private Dictionary&lt;string, Action&lt;AOIEntity&gt;&gt; _onDestroyDict = new Dictionary&lt;string,Action&lt;AOIEntity&gt;&gt;();</span><br><span class="line"></span><br><span class="line">private Dictionary&lt;int, List&lt;AOIEntity&gt;&gt; _indexToEnityDict = new Dictionary&lt;int,List&lt;AOIEntity&gt;&gt;();</span><br><span class="line"></span><br><span class="line">private List&lt;AOIEntity&gt; _curVisiableEntity = new List&lt;AOIEntity&gt;();</span><br><span class="line"></span><br><span class="line">public float gridSize = 10;</span><br><span class="line"></span><br><span class="line">public int AOIRange = 3;</span><br><span class="line"></span><br><span class="line">public GameObject player;</span><br><span class="line"></span><br><span class="line">private int _lastIndex = -1;</span><br></pre></td></tr></table></figure><p>StaticAOIManager使用Key（string）作为不同类型Entity的标识</p><ul><li>_onSpawnDict和_onDestroyDict 是生成和销毁的回调函数</li><li>_indexToEnityDict 是坐标唯一index对应的所有entity的Dict</li><li>_curVisiableEntity 是当前可见的entity，即在AOI范围内的entity</li><li>gridSize 网格切分大小</li><li>AOIRange AOI范围</li><li>_lastIndex 记录上一帧的玩家坐标Index，如果不变不需要进行AOI更新</li></ul><h3 id="世界坐标映射到网格坐标"><a href="#世界坐标映射到网格坐标" class="headerlink" title="世界坐标映射到网格坐标"></a>世界坐标映射到网格坐标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Vector3Int GetGridPos(Vector3 position)</span><br><span class="line">&#123;</span><br><span class="line">    return new Vector3Int(Convert.ToInt32(position.x / gridSize), Convert.ToInt32(position.y / gridSize),</span><br><span class="line">        Convert.ToInt32(position.z / gridSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="网格坐标转成唯一ID"><a href="#网格坐标转成唯一ID" class="headerlink" title="网格坐标转成唯一ID"></a>网格坐标转成唯一ID</h3><p>可以直接用网格坐标作为唯一ID，此处为了性能将网格坐标映射到一个int</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private int GetGridIndexByGridPos(Vector3Int gridPos)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    if (gridPos.x &lt; 0) res = res | (1 &lt;&lt; 11);</span><br><span class="line">    res |= Mathf.Abs(gridPos.x);</span><br><span class="line">    if (gridPos.y &lt; 0) res = res | (1 &lt;&lt; 21);</span><br><span class="line">    res |= Mathf.Abs(gridPos.y);</span><br><span class="line">    if (gridPos.z &lt; 0) res = res | (1 &lt;&lt; 31);</span><br><span class="line">    res |= Mathf.Abs(gridPos.z);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册生成和销毁回调函数"><a href="#注册生成和销毁回调函数" class="headerlink" title="注册生成和销毁回调函数"></a>注册生成和销毁回调函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 注册生成函数</span><br><span class="line">public void Regiseter(string key, Action&lt;AOIEntity&gt; onSpawnCallback, Action&lt;AOIEntity&gt; onDestroyCallback)</span><br><span class="line">&#123;</span><br><span class="line">    if (onSpawnCallback!= null)</span><br><span class="line">        _onSpawnDict[key] = onSpawnCallback;</span><br><span class="line">    if (onDestroyCallback != null)</span><br><span class="line">        _onDestroyDict[key] = onDestroyCallback;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="增加一个Entity的生成点"><a href="#增加一个Entity的生成点" class="headerlink" title="增加一个Entity的生成点"></a>增加一个Entity的生成点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 增加生成点</span><br><span class="line">public void AddSpawnPoint(string key, Vector3 pos, AOIEntity entity)</span><br><span class="line">&#123;</span><br><span class="line">    var index = GetGridIndexByGridPos(GetGridPos(pos));</span><br><span class="line">    if (!_indexToEnityDict.ContainsKey(index))</span><br><span class="line">    &#123;</span><br><span class="line">        _indexToEnityDict.Add(index, new List&lt;AOIEntity&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var entityList = _indexToEnityDict[index];</span><br><span class="line">    entityList.Add(entity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pos表示该entity的生成位置，如果这个pos在AOI范围内会出发生成entity</p><h3 id="AOI更新函数"><a href="#AOI更新函数" class="headerlink" title="AOI更新函数"></a>AOI更新函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">    if (_indexToEnityDict.Count == 0 || player == null) return;</span><br><span class="line"></span><br><span class="line">    var gridPos = GetGridPos(player.transform.position);</span><br><span class="line">    var playerIndex = GetGridIndexByGridPos(gridPos);</span><br><span class="line">    if (playerIndex == _lastIndex) return;</span><br><span class="line"></span><br><span class="line">    _lastIndex = playerIndex;</span><br><span class="line">    List&lt;AOIEntity&gt; enterEntityList = new List&lt;AOIEntity&gt;();</span><br><span class="line">    List&lt;AOIEntity&gt; leaveEntityList = new List&lt;AOIEntity&gt;();</span><br><span class="line">    List&lt;AOIEntity&gt; newVisiableEntityList = new List&lt;AOIEntity&gt;();</span><br><span class="line">    for (int i = -AOIRange; i &lt; AOIRange; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = -AOIRange; j &lt; AOIRange; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            for (int k = -AOIRange; k &lt; AOIRange; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                var index = GetGridIndexByGridPos(new Vector3Int(gridPos.x + i, gridPos.y + j, gridPos.z + k));</span><br><span class="line">                _indexToEnityDict.TryGetValue(index, out var entityList);</span><br><span class="line">                if (entityList != null)</span><br><span class="line">                &#123;</span><br><span class="line">                    newVisiableEntityList.AddRange(entityList);</span><br><span class="line">                    foreach (var entity in entityList)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (!_curVisiableEntity.Contains(entity))</span><br><span class="line">                        &#123;</span><br><span class="line">                            enterEntityList.Add(entity);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    foreach (var entity in _curVisiableEntity)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!newVisiableEntityList.Contains(entity))</span><br><span class="line">        &#123;</span><br><span class="line">            leaveEntityList.Add(entity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    _curVisiableEntity = newVisiableEntityList;</span><br><span class="line">    foreach (var entity in enterEntityList)</span><br><span class="line">    &#123;</span><br><span class="line">        _onSpawnDict.TryGetValue(entity.key, out var onSpawnCallback);</span><br><span class="line">        if (onSpawnCallback != null)</span><br><span class="line">        &#123;</span><br><span class="line">            onSpawnCallback.Invoke(entity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    foreach (var entity in leaveEntityList)</span><br><span class="line">    &#123;</span><br><span class="line">        _onDestroyDict.TryGetValue(entity.key, out var onDestroyCallback);</span><br><span class="line">        if (onDestroyCallback != null)</span><br><span class="line">        &#123;</span><br><span class="line">            onDestroyCallback.Invoke(entity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行逻辑大体是，如果玩家位置对应的网格坐标发生了变化，需要进行AOI的Entity更新<br>AOI的Entity更新步骤如下：</p><ul><li>获取新AOI范围内的所有entity</li><li>计算新进入的entity，调用onSpawn回调</li><li>计算离开的entity，调用onDestroy回调</li><li>更新当前的AOI范围内的entity数组</li></ul><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class CubeEntity : AOIEntity</span><br><span class="line">&#123;</span><br><span class="line">    public GameObject cube;</span><br><span class="line">    public Vector3 position;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CubeSpawn: MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public GameObject prefab;</span><br><span class="line">    </span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        StaticAOIManager.Instance.Regiseter(&quot;cube&quot;, OnSpawnCallback, OnDestroyCallback);</span><br><span class="line"></span><br><span class="line">        CubeEntity cubeEntity1 = new CubeEntity();</span><br><span class="line">        cubeEntity1.key = &quot;cube&quot;;</span><br><span class="line">        cubeEntity1.position = new Vector3(0, 0, 0);</span><br><span class="line">        CubeEntity cubeEntity2 = new CubeEntity();</span><br><span class="line">        cubeEntity2.key = &quot;cube&quot;;</span><br><span class="line">        cubeEntity2.position = new Vector3(40, 0, 0);</span><br><span class="line">        </span><br><span class="line">        StaticAOIManager.Instance.AddSpawnPoint(&quot;cube&quot;, cubeEntity1.position, cubeEntity1);</span><br><span class="line">        StaticAOIManager.Instance.AddSpawnPoint(&quot;cube&quot;, cubeEntity2.position, cubeEntity2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnSpawnCallback(AOIEntity obj)</span><br><span class="line">    &#123;</span><br><span class="line">        var cubeEntity = obj as CubeEntity;</span><br><span class="line">        cubeEntity.cube = Instantiate(prefab);</span><br><span class="line">        cubeEntity.cube.SetActive(true);</span><br><span class="line">        cubeEntity.cube.transform.position = cubeEntity.position;</span><br><span class="line">        Debug.Log(&quot;spawn cube&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void OnDestroyCallback(AOIEntity obj)</span><br><span class="line">    &#123;</span><br><span class="line">        var cubeEntity = obj as CubeEntity;</span><br><span class="line">        Destroy(cubeEntity.cube);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后续优化空间"><a href="#后续优化空间" class="headerlink" title="后续优化空间"></a>后续优化空间</h2><ul><li>这种AOI范围是比较简单粗暴的，如果玩家在网格边界反复横条，会导致entity频繁生成和销毁，对此可以（1）离开后设置entity延迟销毁时间，如果在延迟时间内entity重新进入AOI，则该entity不需要销毁（2）设置一个比AOI范围更大的离开范围，只有entity在离开范围外才触发entity销毁</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> AOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity相机拍照和水印</title>
      <link href="/2022/10/20/Unity%E7%9B%B8%E6%9C%BA%E6%8B%8D%E7%85%A7%E5%92%8C%E6%B0%B4%E5%8D%B0/"/>
      <url>/2022/10/20/Unity%E7%9B%B8%E6%9C%BA%E6%8B%8D%E7%85%A7%E5%92%8C%E6%B0%B4%E5%8D%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Unity相机拍摄"><a href="#Unity相机拍摄" class="headerlink" title="Unity相机拍摄"></a>Unity相机拍摄</h3><p>实现思路：利用render texture将相机的渲染结果放在对应的texture上，texture2D.ReadPixels()和texture2D.Apply()可以将读取到camera到渲染结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-- 相机对拍摄区域拍照</span><br><span class="line">function UIPhoto:TakePhoto()</span><br><span class="line">    rt = URenderTexture.GetTemporary(</span><br><span class="line">        UScreen.width, </span><br><span class="line">        UScreen.height, </span><br><span class="line">        0, </span><br><span class="line">        URenderTextureFormat.ARGB32,</span><br><span class="line">        URenderTextureReadWrite.sRGB)</span><br><span class="line">    local previous = URenderTexture.active</span><br><span class="line">    </span><br><span class="line">    mainCamera = CameraSystem.GetMainCamera()</span><br><span class="line"></span><br><span class="line">    local cameraData = CS.UnityEngine.Rendering.Universal.CameraExtensions.GetUniversalAdditionalCameraData(mainCamera);</span><br><span class="line">    cameraData.renderType = CS.UnityEngine.Rendering.Universal.CameraRenderType.Base;</span><br><span class="line"></span><br><span class="line">    mainCamera.targetTexture = rt</span><br><span class="line">    mainCamera:Render()</span><br><span class="line">    URenderTexture.active = rt</span><br><span class="line">    </span><br><span class="line">    screenShot = UTexture2D(UScreen.width, UScreen.height, CS.UnityEngine.TextureFormat.RGBA32, false)</span><br><span class="line"></span><br><span class="line">    -- 读取屏幕像素信息并存储为纹理数据</span><br><span class="line">    screenShot:ReadPixels(CS.UnityEngine.Rect(0, 0, UScreen.width, UScreen.height), 0, 0)</span><br><span class="line">    screenShot:Apply()</span><br><span class="line">    cameraData.renderType = CS.UnityEngine.Rendering.Universal.CameraRenderType.Overlay;</span><br><span class="line">    mainCamera.targetTexture = nil</span><br><span class="line">    </span><br><span class="line">    URenderTexture.active = previous</span><br><span class="line">    URenderTexture:ReleaseTemporary(rt)</span><br><span class="line"></span><br><span class="line">return screenShot</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>Notes: 如果在没有渲染结果时调用ReadPixels()会报错：ReadPixels was called to read pixels from system frame buffer, while not inside drawing frame. UnityEngine.Texture2D:ReadPixels</p><p>有以下三种解决方式</p><ul><li>在调用ReadPixels()前手动调用相机渲染，即调用Camera.Render()</li><li>在C#的private void OnPostRender()中调用ReadPixels()</li><li>在调用ReadPixels()前使用 yield return new WaitForEndOfFrame()</li></ul><h3 id="图片水印"><a href="#图片水印" class="headerlink" title="图片水印"></a>图片水印</h3><p>实现思路一：</p><ul><li>（1）得到水印texture </li><li>（2）计算水印的相对位置 </li><li>（3）利用texture2D.GetPixel(i, j) 和texture2D.SetPixels()把水印图片附加到原图上</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-- 图片加游戏 Logo</span><br><span class="line">-- offset表示logo图片在原图上的相对位置，范围是0-1</span><br><span class="line">local function AddGameLogo(orignalTexture, offsetX, offsetY)</span><br><span class="line">    local ResourceManager = require(&quot;Game/ResourceManager&quot;)</span><br><span class="line">local width = orignalTexture.width</span><br><span class="line">local height = orignalTexture.height</span><br><span class="line"></span><br><span class="line">    local CoroutineManager = require(&#x27;Game/CoroutineManager&#x27;)</span><br><span class="line">    CoroutineManager.Create(</span><br><span class="line">        function()</span><br><span class="line">            local newTexture = UTexture2D(width, height, CS.UnityEngine.TextureFormat.RGB24, false)</span><br><span class="line">            local logoTexture = ResourceManager.Load(&#x27;logo&#x27;, typeof(CS.UnityEngine.Texture))</span><br><span class="line">            local offsetWidth = math.floor((width - logoTexture.width) * offsetX)</span><br><span class="line">            local offsetHeight = math.floor((height - logoTexture.height) * offsetY)</span><br><span class="line"></span><br><span class="line">            local colors = orignalTexture:GetPixels()</span><br><span class="line">            for i = 1, logoTexture.width do</span><br><span class="line">                for j = 1, logoTexture.height do</span><br><span class="line">                    -- body</span><br><span class="line">                    local newColor = logoTexture:GetPixel(i, j)</span><br><span class="line">                    if newColor.a ~= 0 then</span><br><span class="line">                        colors[width * (j + offsetHeight -1) + offsetWidth + i - 1] = newColor</span><br><span class="line">                    end</span><br><span class="line">                end</span><br><span class="line">            end</span><br><span class="line">            newTexture:SetPixels(0, 0, width, height, colors)</span><br><span class="line">            newTexture:Apply(false)</span><br><span class="line">            </span><br><span class="line">        end</span><br><span class="line">    )</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>实现思路二：</p><p>上述实现思路中SetPixels在CPU上运行，如果对大量的像素点使用SetPixels发放，会造成卡顿，因此需要一种在GPU处理图片运行的快速方法。</p><ul><li>写一个依据透明度混合两个Texture的shader</li><li>使用Blit接口调用上述Shdaer混合Texture</li></ul><h3 id="文字水印"><a href="#文字水印" class="headerlink" title="文字水印"></a>文字水印</h3><p>如果是静态的文字可直接制作文字的图片，然后用上面的加图片水印的方式增加文字水印。</p><p>如果是动态的文字，主要的实现思路如下：</p><ul><li><p>在UI中创建需要显示的特定Text，同时指定一个特定的Layer供相机渲染</p></li><li><p>创建render texture，指定相机的渲染layer，注意相机的render type必须为base，即</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/20.png?raw=true" alt="image-20220602160849086"></p></li></ul><p>如果在相机在overlay模式无法输出渲染结果到render texture</p><ul><li>得到文字水印的render texture后通过图片水印的方式增加文字水印</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mainCamera = GetGame().windowManager.camera</span><br><span class="line">local layerMask = 1 &lt;&lt; ULayerMask.NameToLayer(&quot;Watermark&quot;)</span><br><span class="line">local cacheLayerMesh = mainCamera.cullingMask</span><br><span class="line">local cameraData = CS.UnityEngine.Rendering.Universal.CameraExtensions.GetUniversalAdditionalCameraData(mainCamera);</span><br><span class="line">cameraData.renderType = CS.UnityEngine.Rendering.Universal.CameraRenderType.Base;</span><br><span class="line">mainCamera.cullingMask = layerMask</span><br><span class="line"></span><br><span class="line">mainCamera.targetTexture = rt</span><br><span class="line">mainCamera:Render()</span><br><span class="line">URenderTexture.active = rt</span><br><span class="line"></span><br><span class="line">screenShot = UTexture2D(UScreen.width, UScreen.height, CS.UnityEngine.TextureFormat.RGBA32, false)</span><br><span class="line"></span><br><span class="line">-- 读取屏幕像素信息并存储为纹理数据</span><br><span class="line">screenShot:ReadPixels(CS.UnityEngine.Rect(0, 0, UScreen.width, UScreen.height), 0, 0)</span><br><span class="line">screenShot:Apply()</span><br><span class="line">mainCamera.cullingMask = cacheLayerMesh</span><br><span class="line">mainCamera.targetTexture = nil</span><br><span class="line"></span><br><span class="line">URenderTexture.active = previous</span><br><span class="line">URenderTexture:ReleaseTemporary(rt)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity DOTS技术</title>
      <link href="/2022/08/20/Unity%20DOTS%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/08/20/Unity%20DOTS%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="DOTS"><a href="#DOTS" class="headerlink" title="DOTS"></a>DOTS</h2><ul><li>Job System</li><li>Burst编译器，native code</li><li>ECS</li></ul><h2 id="JobSystem"><a href="#JobSystem" class="headerlink" title="JobSystem"></a>JobSystem</h2><p><a href="https://docs.unity3d.com/cn/current/Manual/JobSystemNativeContainer.html">NativeContainer - Unity 手册 (unity3d.com)</a></p><p>Job System是Unity的多线程高性能的Worker框架，是Unity的底层技术之一。</p><p>传统多线程的可能问题：</p><ul><li>死锁</li><li>资源竞争</li></ul><p>Job System能够更安全的写多线程代码</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>创建worker线程（非必要，主线程也能是worker线程）</li><li>将数据复制到worker</li><li>worker线程完成计算</li><li>结果同步</li></ul><p>原始数据自动锁定，由编译器保证其无法被占用，如果访问相同变量，会报错。</p><h3 id="数据复制、数据安全"><a href="#数据复制、数据安全" class="headerlink" title="数据复制、数据安全"></a>数据复制、数据安全</h3><p>Job System会检测所有的竞争条件，确保同一时间所有的job不存在竞争条件。 C# 作业系统通过向每个作业发送它需要操作的数据的副本来解决这个问题，而不是对控制线程中的数据的引用。 此副本隔离了数据，从而消除了竞争条件。</p><p>Job System的数据存放在非托管内存中，Job System只能访问<strong>blittable</strong>类型的数据，在托管代码和native code之间这些数据无需转换。作业调度时，使用<strong>memcpy</strong>将数据复制到非托管内存中。</p><p>在作业中分配托管内存非常慢，而且作业无法使用 Unity <a href="https://www.youtube.com/watch?v=NF6kcNS6U80&t=2s">Burst 编译器</a>来提高性能。Burst 是一种新的基于 <a href="https://en.wikipedia.org/wiki/LLVM">LLVM</a> 的后端编译器技术，可以简化您的工作。此编译器获取 C# 作业并生成高度优化的机器代码，从而利用目标平台的特定功能。</p><p><a href="https://docs.unity3d.com/cn/current/Manual/JobSystemSafetySystem.html">安全系统</a>复制数据的过程的缺点是会将作业的结果隔离到每个副本中。为了克服此限制，需要将结果存储在一种名为 <a href="https://docs.unity3d.com/cn/current/ScriptReference/Unity.Collections.LowLevel.Unsafe.NativeContainerAttribute.html">NativeContainer</a> 的共享内存中。</p><h3 id="作业依赖"><a href="#作业依赖" class="headerlink" title="作业依赖"></a>作业依赖</h3><p>如果一个job依赖另一个job，需要通过代码建立他们的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JobHandle firstJobHandle = firstJob.Schedule();</span><br><span class="line">secondJob.Schedule(firstJobHandle);</span><br></pre></td></tr></table></figure><p>如果一个作业具有许多依赖项，则可以使用 <a href="https://docs.unity3d.com/cn/current/ScriptReference/Unity.Jobs.JobHandle.CombineDependencies.html">JobHandle.CombineDependencies</a> 方法合并这些依赖项。<code>CombineDependencies</code> 可以将依赖项传递给 <code>Schedule</code> 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NativeArray&lt;JobHandle&gt; handles = new NativeArray&lt;JobHandle&gt;(numJobs, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">// 使用来自多个调度作业的 `JobHandles` 填充 `handles`...</span><br><span class="line"></span><br><span class="line">JobHandle jh = JobHandle.CombineDependencies(handles);</span><br></pre></td></tr></table></figure><h3 id="例子：Sum"><a href="#例子：Sum" class="headerlink" title="例子：Sum"></a>例子：Sum</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public struct ParallelSumJob : IJobFor</span><br><span class="line">&#123;</span><br><span class="line">    [ReadOnly]</span><br><span class="line">    public NativeArray&lt;float&gt; a;</span><br><span class="line">    [ReadOnly]</span><br><span class="line">    public NativeArray&lt;float&gt; b;</span><br><span class="line">    public NativeArray&lt;float&gt; result;</span><br><span class="line"></span><br><span class="line">    public void Execute(int i)</span><br><span class="line">    &#123;</span><br><span class="line">        result[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class JobSample : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public static int len = 100000;</span><br><span class="line">    </span><br><span class="line">    NativeArray&lt;float&gt; a;</span><br><span class="line">    NativeArray&lt;float&gt; b;</span><br><span class="line">    NativeArray&lt;float&gt; result;</span><br><span class="line"></span><br><span class="line">    private void Job()</span><br><span class="line">    &#123;</span><br><span class="line">        DateTime beginTime = DateTime.Now;</span><br><span class="line">        a = new NativeArray&lt;float&gt;(len, Allocator.TempJob);</span><br><span class="line">        b = new NativeArray&lt;float&gt;(len, Allocator.TempJob);</span><br><span class="line">        result = new NativeArray&lt;float&gt;(len, Allocator.TempJob);</span><br><span class="line">            </span><br><span class="line">        for (int i = 0; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = 1;</span><br><span class="line">            b[i] = 2;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        ParallelSumJob jobData = new ParallelSumJob();</span><br><span class="line">        jobData.a = a;  </span><br><span class="line">        jobData.b = b;</span><br><span class="line">        jobData.result = result;</span><br><span class="line">            </span><br><span class="line">        var handle = jobData.ScheduleParallel(len, 32, new JobHandle());</span><br><span class="line">        handle.Complete();</span><br><span class="line">            </span><br><span class="line">        Debug.Log(jobData.result[0]);</span><br><span class="line">        </span><br><span class="line">        // Native arrays must be disposed manually.</span><br><span class="line">        a.Dispose();</span><br><span class="line">        b.Dispose();</span><br><span class="line">        result.Dispose();</span><br><span class="line">            </span><br><span class="line">        DateTime endTime = DateTime.Now;              //获取结束时间  </span><br><span class="line">        TimeSpan oTime = endTime.Subtract(beginTime); </span><br><span class="line">        Debug.Log($&quot;程序的运行时间：&#123;oTime.TotalMilliseconds&#125; 毫秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="例子：JobSystem-实现鱼群"><a href="#例子：JobSystem-实现鱼群" class="headerlink" title="例子：JobSystem 实现鱼群"></a>例子：JobSystem 实现鱼群</h3><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/21.png?raw=true" alt="image-20221112170724424"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">public class FishGenerator : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    [BurstCompile]</span><br><span class="line">    private struct FishPositionUpdateJob: IJobParallelForTransform</span><br><span class="line">    &#123;</span><br><span class="line">        public NativeArray&lt;float3&gt; objectVelocities;</span><br><span class="line">        </span><br><span class="line">        public float swimSpeed;</span><br><span class="line"></span><br><span class="line">        public float deltaTime;</span><br><span class="line"></span><br><span class="line">        public float turnSpeed;</span><br><span class="line">        </span><br><span class="line">        public int swimChangeFrequency;</span><br><span class="line"></span><br><span class="line">        public float3 center;</span><br><span class="line"></span><br><span class="line">        public float3 bounds;</span><br><span class="line">        </span><br><span class="line">        [NativeDisableContainerSafetyRestriction]</span><br><span class="line">        public NativeArray&lt;Unity.Mathematics.Random&gt; randomArray;</span><br><span class="line">        </span><br><span class="line">        [NativeSetThreadIndex]</span><br><span class="line">        private int _threadId;</span><br><span class="line"></span><br><span class="line">        public void Execute(int index, TransformAccess transform)</span><br><span class="line">        &#123;</span><br><span class="line">            Unity.Mathematics.Random random = randomArray[_threadId];</span><br><span class="line">            transform.position += transform.localToWorldMatrix.MultiplyVector(new Vector3(0, 0, 1)) *</span><br><span class="line">                                  swimSpeed * deltaTime * random.NextFloat(0.3f, 1.0f);</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            var curVelocity = objectVelocities[index];</span><br><span class="line">            if (!curVelocity.Equals(float3.zero))</span><br><span class="line">            &#123;</span><br><span class="line">                transform.rotation = Quaternion.Lerp(transform.rotation, </span><br><span class="line">                    Quaternion.LookRotation(curVelocity), turnSpeed * deltaTime);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            // prevent a fish-out-of-bound</span><br><span class="line">            var curPosition = transform.position;</span><br><span class="line">            bool randomise = true;</span><br><span class="line">            </span><br><span class="line">            if (curPosition.x &gt; center.x + bounds.x || </span><br><span class="line">                curPosition.x &lt; center.x - bounds.x || </span><br><span class="line">                curPosition.z &gt; center.z + bounds.z || </span><br><span class="line">                curPosition.z &lt; center.z - bounds.z)</span><br><span class="line">            &#123;</span><br><span class="line">                Vector3 internalPosition = new Vector3(center.x + random.NextFloat(-bounds.x, bounds.x)/1.3f, </span><br><span class="line">                    0, center.z + random.NextFloat(-bounds.z, bounds.z)/1.3f);</span><br><span class="line">                curVelocity = (internalPosition- curPosition).normalized;</span><br><span class="line">                objectVelocities[index] = curVelocity;</span><br><span class="line">                transform.rotation = Quaternion.Lerp(transform.rotation, </span><br><span class="line">                    Quaternion.LookRotation(curVelocity), </span><br><span class="line">                    turnSpeed * deltaTime * 2);</span><br><span class="line">                randomise = false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (randomise)</span><br><span class="line">            &#123;</span><br><span class="line">                if (random.NextInt(0, swimChangeFrequency) &lt;= 2)</span><br><span class="line">                &#123;</span><br><span class="line">                    objectVelocities[index] = new Vector3(random.NextFloat(-1f, 1f),</span><br><span class="line">                        0, random.NextFloat(-1f, 1f));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            randomArray[_threadId] = random;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private FishPositionUpdateJob _fishPositionUpdateJob;</span><br><span class="line"></span><br><span class="line">    private NativeArray&lt;float3&gt; _objectVelocities;</span><br><span class="line"></span><br><span class="line">    private NativeArray&lt;Unity.Mathematics.Random&gt; _randoms;</span><br><span class="line">    </span><br><span class="line">    private NativeArray&lt;float3&gt; _velocities;</span><br><span class="line"></span><br><span class="line">    private TransformAccessArray _transformAccessArray;</span><br><span class="line"></span><br><span class="line">    public GameObject FishTemplate;</span><br><span class="line">    </span><br><span class="line">    public int fishCount;</span><br><span class="line">    </span><br><span class="line">    public BoxCollider spawnBounds;</span><br><span class="line">    </span><br><span class="line">    public float spawnHeight;</span><br><span class="line">    </span><br><span class="line">    public int swimChangeFrequency;</span><br><span class="line">    </span><br><span class="line">    // Start is called before the first frame update</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        _velocities = new NativeArray&lt;float3&gt;(fishCount, Allocator.Persistent);</span><br><span class="line">        _transformAccessArray = new TransformAccessArray(fishCount);</span><br><span class="line">        _objectVelocities = new NativeArray&lt;float3&gt;(fishCount, Allocator.Persistent);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; fishCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            float distanceX = UnityEngine.Random.Range(-spawnBounds.bounds.extents.x, spawnBounds.bounds.extents.x);</span><br><span class="line">            float distanceZ = UnityEngine.Random.Range(-spawnBounds.bounds.extents.z, spawnBounds.bounds.extents.z);</span><br><span class="line"></span><br><span class="line">            Vector3 spawnPoint = spawnBounds.bounds.center + Vector3.up * spawnHeight + new Vector3(distanceX, 0, distanceZ);</span><br><span class="line"></span><br><span class="line">            // generare fish obj</span><br><span class="line">            var go = GameObject.Instantiate(FishTemplate, spawnPoint, Quaternion.identity);</span><br><span class="line">            _transformAccessArray.Add(go.transform);</span><br><span class="line">            </span><br><span class="line">            // _objectVelocities[i] = new float3(1, 1, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 生成线程数量的随机种子</span><br><span class="line">        _randoms = new NativeArray&lt;Unity.Mathematics.Random&gt;(JobsUtility.MaxJobThreadCount, Allocator.TempJob);</span><br><span class="line">        for (int i = 0; i &lt; _randoms.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            _randoms[i] = Unity.Mathematics.Random.CreateFromIndex((uint) i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _fishPositionUpdateJob = new FishPositionUpdateJob()</span><br><span class="line">        &#123;</span><br><span class="line">            randomArray = _randoms,</span><br><span class="line">            swimSpeed = 0.2f,</span><br><span class="line">            objectVelocities = _objectVelocities,</span><br><span class="line">            turnSpeed = 4.6f,</span><br><span class="line">            swimChangeFrequency = swimChangeFrequency,</span><br><span class="line">            center = spawnBounds.bounds.center,</span><br><span class="line">            bounds = spawnBounds.bounds.extents,</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Update is called once per frame</span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        _fishPositionUpdateJob.deltaTime = Time.deltaTime;</span><br><span class="line">        var jobHandle = _fishPositionUpdateJob.Schedule(_transformAccessArray, default);</span><br><span class="line">        jobHandle.Complete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnDestroy()</span><br><span class="line">    &#123;</span><br><span class="line">        _velocities.Dispose();</span><br><span class="line">        _transformAccessArray.Dispose();</span><br><span class="line">        _randoms.Dispose();</span><br><span class="line">        _objectVelocities.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>（1）unity中 GetComponment<T>() 只比 GetComponment(typeof(T)) 高效一点点，但却比 GetComponment(string) 高效接近一百倍。所以，<strong>应该确保不要使用 GetComponment(string) 方法</strong>。除了一些罕见的情况，比如需要使用它来解析用户输入的字符串，从而获取一个组件。这种情况一般只会发生在自定义的调试控制器上，而对于产品级的应用，GetComponment(string) 是一种不必要的浪费。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows搭建Games101环境</title>
      <link href="/2022/04/24/Windows%E6%90%AD%E5%BB%BAGames101%E7%8E%AF%E5%A2%83/"/>
      <url>/2022/04/24/Windows%E6%90%AD%E5%BB%BAGames101%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>本方法是通过windows平台vcpkg工具安装所需环境</p><h2 id="安装vcpkg"><a href="#安装vcpkg" class="headerlink" title="安装vcpkg"></a>安装vcpkg</h2><ul><li><p>git安装vckpg（也可以通过其他方式）</p><p>git命令： git clone <a href="mailto:&#x67;&#105;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#109;">&#x67;&#105;&#x74;&#64;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#109;</a>:microsoft&#x2F;vcpkg.git</p></li><li><p>进入vcpkg目录执行bootstep-vcpkg.bat脚本</p></li><li><p>安装所需要的包，这一步需要在vcpkg目录下执行cm命令，或者将vcpkg目录添加到系统path变量上</p><p>命令：</p><p>vcpkg.exe install opencv:x64-windows</p><p>vcpkg.exe install eigen:x64-windows</p><p>这一步就是安装所需要的包，后面cmake过程出现的缺少包都可以通过这一步来安装</p></li></ul><h2 id="关联vcpkg安装好的包到Visual-Studio"><a href="#关联vcpkg安装好的包到Visual-Studio" class="headerlink" title="关联vcpkg安装好的包到Visual Studio"></a>关联vcpkg安装好的包到Visual Studio</h2><ul><li><p>执行命令：</p><p>vcpkg.exe integrate project</p></li></ul><h2 id="Games101-作业编译"><a href="#Games101-作业编译" class="headerlink" title="Games101 作业编译"></a>Games101 作业编译</h2><ul><li><p>在作业的工程文件夹执行下面的命令：</p><p>mkdir build</p><p>cd build</p><p>cmake ..  (这一步如果缺少包可以通过步骤一的vcpkg进行安装)</p></li><li><p>然后就可以通过vs或者vs code打开build文件夹下的sln文件进行后续的编程了</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Game101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity Slate和行为树接入</title>
      <link href="/2022/03/28/Slate%E5%92%8C%E8%A1%8C%E4%B8%BA%E6%A0%91%E6%8E%A5%E5%85%A5/"/>
      <url>/2022/03/28/Slate%E5%92%8C%E8%A1%8C%E4%B8%BA%E6%A0%91%E6%8E%A5%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>Unity Slate插件是一个TimeLine编辑器。支持在时间轴上编辑镜头、Animation、音频、角色IK等各种功能，支持扩展各种自定义节点类型。同时对Node Canvas行为树的支持也非常友好，直接集成了向行为树发送事件节点。</p><p>Slate使用界面：</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/22.png?raw=true" alt="image-20211214095943932"></p><p>通过添加Cutscene脚本即可编辑TimeLine，一个Slate Editor中可以同时存在多个组（Actor Group），Director为Slate自带的组，其余添加组的属性都带组名和GameObject。一个组内可同时存在多个轨道（Track），一个轨道是一个TImeLine，在TimeLine上可以编辑多个节点（Action Clip）,节点会在对应的时刻触发并执行对应函数。Action Clip为具体的行为片段。例如播放动画、播放特效、发送事件等功能</p><p>Slate支持自定义节点，只需要继承实现Action Clip，并且将节点添加到轨道上即可完成触发。</p><p>Slate的更新顺序为：</p><p>Group Enter -&gt; Track Enter -&gt; Clip Enter |   ··· Clip Update  ···   | Clip Exit -&gt; Track Exit -&gt; Group Exit</p><h2 id="Slate接入行为树"><a href="#Slate接入行为树" class="headerlink" title="Slate接入行为树"></a>Slate接入行为树</h2><p>行为树接入Slate主要需要实现：</p><ul><li>生成行为树的Task节点用于播放和暂停Slate</li><li>行为树和Slate的数据交互（可以通过黑板和事件交互）</li><li>序列化Slate数据</li></ul><p>下面以Node Canvas行为树为例，</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>客户端：</p><p>方案一可以直接将Cutscene脚本挂载到GameObject，通过序列化Prefab的方式序列化Slate数据。在行为树执行对应Slate Task时，播放Slate只需要初始化GameObject并且调用CutScene的Play方法即可。</p><p>方案二可以直接Cutscene的数据序列话成JSON、BSON等格式，运行时反序列化。</p><p>服务端：如果需要在服务端执行Slate的逻辑，需要在序列化Slate配置数据，并且在服务端实现Slate的运行逻辑。</p><h3 id="生成行为树节点播放Slate"><a href="#生成行为树节点播放Slate" class="headerlink" title="生成行为树节点播放Slate"></a>生成行为树节点播放Slate</h3><p>由于序列化生成Slate节点无法得到运行时Actor Group的GameObject，需要我们在运行时动态设置。Cutscene中提供了方法SetGroupActorOfName(string groupName, GameObject newActor)，该方法可以通过组名查找替换当前的GameObject。我们可以将Slate需要的Gameobject放在黑板数据中，运行时将黑板GameObject设置到CutScene中即可。</p><p>Play Slate的Task节点：</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/23.png?raw=true"></p><p>左侧Cutscene为序列化的Slate Prefab，图中Group Name为Actor Group中的组名，New Actor为黑板数据，运行该Task节点会将New Actor设置为Actor Group对应的GameObject。</p><p>Task节点部分代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protected override void OnExecute() &#123;</span><br><span class="line"></span><br><span class="line">    if ( cutscene.value.isActive ) &#123;</span><br><span class="line">        EndAction();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cutsceneInstance = cutsceneIsPrefab ? Object.Instantiate(cutscene.value) : cutscene.value;</span><br><span class="line"></span><br><span class="line">    foreach ( var replacement in replacementActors ) &#123;</span><br><span class="line">        if ( !string.IsNullOrEmpty(replacement.groupName) &amp;&amp; replacement.newActor.value != null ) &#123;</span><br><span class="line">            cutsceneInstance.SetGroupActorOfName(replacement.groupName, replacement.newActor.value);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cutsceneInstance.defaultStopMode = stopMode;</span><br><span class="line">    if ( waitActionFinish ) &#123;</span><br><span class="line">        cutsceneInstance.Play(startTime.value, cutsceneInstance.length, wrapMode, () =&gt; &#123; FinalizeCutscene(); EndAction(); &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cutsceneInstance.Play(startTime.value, cutsceneInstance.length, wrapMode, () =&gt; &#123; FinalizeCutscene(); &#125;);</span><br><span class="line">        EndAction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected override void OnStop() &#123;</span><br><span class="line">    if ( waitActionFinish &amp;&amp; cutscene.value.isActive ) &#123;</span><br><span class="line">        cutsceneInstance.Stop(stopMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><h4 id="共享黑板"><a href="#共享黑板" class="headerlink" title="共享黑板"></a>共享黑板</h4><p>可以通过共享行为树黑板的方式来实现数据传递。修改Slate代码，在Actor Group中添加BlackBoard变量，在初始化Slate节点时将行为树黑板传递进Actor Group。后续任何行为树的Task节点都可以直接访问行为树的黑板</p><p>Slate添加碰撞检测节点的代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CollisionActionClip</span> : <span class="title">ActorActionClip</span>&lt;<span class="title">Blackboard</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> BBName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;GameObject&gt; <span class="keyword">value</span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Application.isPlaying)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">value</span> = Helper.Search(ActorGameObject.transform.position, <span class="number">10</span>, LayerMask.GetMask(<span class="string">&quot;Default&quot;</span>));</span><br><span class="line">            Blackboard.SetVariableValue(BBName, <span class="keyword">value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> mRec = <span class="keyword">new</span> GameObject(<span class="string">&quot;temp&quot;</span>);</span><br><span class="line">            mRec.transform.localScale = Vector3.one;</span><br><span class="line">            UDrawTool tool;</span><br><span class="line">            tool = mRec.AddComponent&lt;UDrawTool&gt;();</span><br><span class="line">            tool.DrawCube(mRec.transform, Vector3.zero, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, Quaternion.identity, <span class="number">1f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="发送事件"><a href="#发送事件" class="headerlink" title="发送事件"></a>发送事件</h4><p>Slate向行为树发送event代码，支持发送各种类型的数据</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SendGraphEvent</span>&lt;<span class="title">T</span>&gt; : <span class="title">ActorActionClip</span>&lt;<span class="title">GraphOwner</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> eventName;</span><br><span class="line">    <span class="keyword">public</span> T eventValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnEnter</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( Application.isPlaying ) &#123;</span><br><span class="line">            actor.SendEvent(eventName, eventValue, root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE-GAS(技能系统)</title>
      <link href="/2022/03/20/UE-GAS(%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F)/"/>
      <url>/2022/03/20/UE-GAS(%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F)/</url>
      
        <content type="html"><![CDATA[<p>英文文档：<a href="https://github.com/tranek/GASDocumentation#concepts-ge-definition">https://github.com/tranek/GASDocumentation#concepts-ge-definition</a></p><p>中文文档：<a href="https://github.com/BillEliot/GASDocumentation_Chinese#45-gameplay-effects">https://github.com/BillEliot/GASDocumentation_Chinese#45-gameplay-effects</a></p><p>GA（GameAblity）</p><p>GE（GameEffect）</p><p>技能冷却机制实现：</p><ul><li>创建GE，持续事件设置为Has Duration，时间设置为CD，增加Tag、</li><li>技能GA的class default中的cooldown Game Effect设置为上面的GE</li><li>GA中的event activateAbility中增加CommitAbility</li></ul><p>GAS执行流程：</p><ul><li><p>通过角色的AbilitySystemCompont执行trytoactivateability(FGameplayAbility Ability)可以执行指定GA</p></li><li><p>GA：激活GA后运行Event Activate Ability事件，CommitAbility用于提交扣蓝等功能。</p></li></ul><p><img src="https://github.com/nevermorec/Photo-store/blob/master/GAS/1.png?raw=true" alt="image-20220115174818619"></p><ul><li><p>如果是攻击技能开启碰撞检测。将HitResult或者HItActor放入TargetDataHandle中</p><p>c++放入过程：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FGameplayAbilityTargetDataHandle TargetDataHandle;</span><br><span class="line"></span><br><span class="line">FGameplayAbilityTargetData_SingleTargetHit* TargetData = new FGameplayAbilityTargetData_SingleTargetHit(HitResult);</span><br><span class="line">TargetDataHandle.Add(TargetData);</span><br></pre></td></tr></table></figure><p>蓝图只能单个Actor或者HitResult放入TargetDataHandle中</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/GAS/2.png?raw=true"></p><ul><li><p>对被释放对象施加GE</p><p>蓝图调用ApplyGamePlayEffectToTarget</p><p>C++ 例子如下 TargetEffectSpecs是EffectSpecHandle的数组，ContainerSpec.TargetDataHandle包含要施加GE的actor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TArray&lt;FActiveGameplayEffectHandle&gt; UBaseGameplayAbility::ApplyEffectContainerSpec(</span><br><span class="line">   FGamePlayEffectContainerSpec&amp; ContainerSpec)</span><br><span class="line">&#123;</span><br><span class="line">   TArray&lt;FActiveGameplayEffectHandle&gt; AllEffects;</span><br><span class="line">   for (auto TargetEffectSpec : ContainerSpec.TargetEffectSpecs)</span><br><span class="line">   &#123;</span><br><span class="line">      AllEffects.Append(K2_ApplyGameplayEffectSpecToTarget(TargetEffectSpec, ContainerSpec.TargetDataHandle));</span><br><span class="line">   &#125;</span><br><span class="line">   return AllEffects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="GamePlayAbility-GA"><a href="#GamePlayAbility-GA" class="headerlink" title="GamePlayAbility (GA)"></a>GamePlayAbility (GA)</h2><h3 id="输入键位绑定"><a href="#输入键位绑定" class="headerlink" title="输入键位绑定"></a>输入键位绑定</h3><p>简单的技能释放可以直接在蓝图中根据输入调用TryActivateAbility来激活指定技能。不过如果需要在GA中监听输入按钮的释放事件（Wait Input Release），则这种方式无法触发Wait Input Realse的On Release事件，必须在授予技能时指定FGameplayAbilitySpec中的InInputID，在GAS的按钮监听中UAbilitySystemComponent::AbilityLocalInputPressed才能触发按钮的Release事件</p><h4 id="绑定单个技能到特定键位"><a href="#绑定单个技能到特定键位" class="headerlink" title="绑定单个技能到特定键位"></a>绑定单个技能到特定键位</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">AMyCCharacter::AddAbilityOnInput</span><span class="params">(TSubclassOf&lt;UGameplayAbility&gt; Ability, FString InputValue, int32 InputID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (AbilitySystemComp &amp;&amp; Ability)</span><br><span class="line">   &#123;</span><br><span class="line">      AbilitySystemComp-&gt;<span class="built_in">GiveAbility</span>(<span class="built_in">FGameplayAbilitySpec</span>(Ability, <span class="number">1</span>, InputID));</span><br><span class="line">      AbilitySystemComp-&gt;<span class="built_in">InitAbilityActorInfo</span>(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="function">FInputActionBinding <span class="title">ABPressed</span><span class="params">(FName(InputValue), IE_Pressed)</span></span>;</span><br><span class="line">      ABPressed.ActionDelegate.<span class="built_in">GetDelegateForManualSet</span>().<span class="built_in">BindUObject</span>(AbilitySystemComp, &amp;UBaseAbilitySystemComponent::AbilityLocalInputPressed, InputID);</span><br><span class="line">      InputComponent-&gt;<span class="built_in">AddActionBinding</span>(ABPressed);</span><br><span class="line"></span><br><span class="line">      <span class="function">FInputActionBinding <span class="title">ABReleased</span><span class="params">(FName(InputValue), IE_Released)</span></span>;</span><br><span class="line">      ABReleased.ActionDelegate.<span class="built_in">GetDelegateForManualSet</span>().<span class="built_in">BindUObject</span>(AbilitySystemComp, &amp;UBaseAbilitySystemComponent::AbilityLocalInputReleased, InputID);</span><br><span class="line">      InputComponent-&gt;<span class="built_in">AddActionBinding</span>(ABReleased);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputValue为项目设置Input对应的键值，InputID为自定义的int32，只要设置为不重复即可。绑定了确认和释放按钮后可以在GA中使用Wait Input Release来完成游戏逻辑。</p><h2 id="GamePlayeEffect（GE）"><a href="#GamePlayeEffect（GE）" class="headerlink" title="GamePlayeEffect（GE）"></a>GamePlayeEffect（GE）</h2><h3 id="GE的执行流程"><a href="#GE的执行流程" class="headerlink" title="GE的执行流程"></a>GE的执行流程</h3><h3 id="属性修改（Attribute-Modifier）"><a href="#属性修改（Attribute-Modifier）" class="headerlink" title="属性修改（Attribute Modifier）"></a>属性修改（Attribute Modifier）</h3><p>在GE中可以包含多个Modifier，而每一个Modifier会设定一个数值和一种运算方式，并对应修改一个Attribute。其中包含四种运算方式：1）Add(加&#x2F;减)；2）Multiply乘；3）Divide除；4）Override覆盖。四种Modifier最终的运算结果在FAggregatorModChannel::EvaluateWithBase里定义，默认：</p><p>CurrentValue &#x3D; ((InlineBaseValue + Additive) * Multiplicitive) &#x2F; Division（如果有Override则直接覆盖结果）</p><p>Modifier的取值有四种类型，这部分的设置十分重要，因为会<strong>与游戏逻辑密切挂钩</strong>：</p><ul><li>Scalable Float：可指定一个表中数据，然后乘上一个因数；</li><li>Attribute Based：以Attribute的值作为基值然后乘上因数（采用快照Snapshotting实现）</li><li><strong>Custom Calculation Class</strong>：自定义类，需要引入一个ModifierMagnitudeCalculation类(MMC)，<a href="https://github.com/tranek/GASDocumentation#4511-modifier-magnitude-calculation">参考范例</a>中根据现有的蓝量和Tag计算最终造成多少蓝量的损失。这种方式的优点时可以被预测而且可用于每一类GE，但最终还是指定修改一种Attribute。</li><li><strong>Set By Caller</strong>：根据释放的技能主体来设定，比如蓄力长短决定的伤害量、资产中设置的数值。需要通过GameplayEffectSpec中的TMap&lt;FGameplayTag, float&gt;索引相关的值，Tag不存在时返回0。这种类型广泛用于可复用的GE。<strong>通过调用AssignTagSetByCallerMagnitude来指定特定Tag对应的float值。</strong></li></ul><h4 id="UGameplayEffectExecutionCalculation-（自定义属性数值计算类）"><a href="#UGameplayEffectExecutionCalculation-（自定义属性数值计算类）" class="headerlink" title="UGameplayEffectExecutionCalculation （自定义属性数值计算类）"></a>UGameplayEffectExecutionCalculation （自定义属性数值计算类）</h4><p>使用方法：</p><ul><li><p>继承UGameplayEffectExecutionCalculation</p></li><li><p>自定义初始化方法（定义从Source和Target捕获的相关属性），</p></li><li><p>overrider Execute_Implementation函数，实现自定义的计算逻辑</p></li></ul><p><strong>初始化方法  方式一：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UPAMMC_PoisonMana::UPAMMC_PoisonMana()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">//ManaDef defined in header FGameplayEffectAttributeCaptureDefinition ManaDef;</span><br><span class="line">ManaDef.AttributeToCapture = UPAAttributeSetBase::GetManaAttribute();</span><br><span class="line">ManaDef.AttributeSource = EGameplayEffectAttributeCaptureSource::Target;</span><br><span class="line">ManaDef.bSnapshot = false;</span><br><span class="line">  </span><br><span class="line">RelevantAttributesToCapture.Add(ManaDef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要定义捕获数据的来源（Source还是Target），哪个属性，快照方式（bSnapshot）</p><p>快照规则如下：</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/GAS/3.png?raw=true" alt="image-20220210141521332"></p><p><strong>方式二：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">RPGDamageStatics</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(AttackPower);</span><br><span class="line"><span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(DefensePower);</span><br><span class="line"><span class="built_in">DECLARE_ATTRIBUTE_CAPTUREDEF</span>(Health);</span><br><span class="line"></span><br><span class="line"><span class="built_in">RPGDamageStatics</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UAttributeSetBase, AttackPower, Source, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UAttributeSetBase, DefensePower, Target, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">DEFINE_ATTRIBUTE_CAPTUREDEF</span>(UAttributeSetBase, Health, Target, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">const</span> RPGDamageStatics&amp; <span class="title">DamageStatics</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> RPGDamageStatics DmgStatics;</span><br><span class="line"><span class="keyword">return</span> DmgStatics;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UAttackEffectExecutionCalculation::<span class="built_in">UAttackEffectExecutionCalculation</span>()</span><br><span class="line">&#123;</span><br><span class="line">RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().AttackPowerDef);</span><br><span class="line">RelevantAttributesToCapture.<span class="built_in">Add</span>(<span class="built_in">DamageStatics</span>().DefensePowerDef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UAttackEffectExecutionCalculation::Execute_Implementation</span><span class="params">(<span class="type">const</span> FGameplayEffectCustomExecutionParameters&amp; ExecutionParams,</span></span></span><br><span class="line"><span class="params"><span class="function">   FGameplayEffectCustomExecutionOutput&amp; OutExecutionOutput)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   UAbilitySystemComponent* SourceASC = ExecutionParams.<span class="built_in">GetSourceAbilitySystemComponent</span>();</span><br><span class="line">   UAbilitySystemComponent* TargetASC = ExecutionParams.<span class="built_in">GetTargetAbilitySystemComponent</span>();</span><br><span class="line">   </span><br><span class="line">   FGameplayEffectSpec EffectSpec = ExecutionParams.<span class="built_in">GetOwningSpec</span>();</span><br><span class="line"></span><br><span class="line">   FAggregatorEvaluateParameters EvaluateParameters;</span><br><span class="line">   EvaluateParameters.SourceTags = EffectSpec.CapturedSourceTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line">   EvaluateParameters.TargetTags = EffectSpec.CapturedTargetTags.<span class="built_in">GetAggregatedTags</span>();</span><br><span class="line"></span><br><span class="line">   <span class="type">float</span> AttackPower = <span class="number">0.0f</span>;</span><br><span class="line">   ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().AttackPowerDef, EvaluateParameters, AttackPower);</span><br><span class="line"></span><br><span class="line">   <span class="type">float</span> DefensePower = <span class="number">0.0f</span>;</span><br><span class="line">   ExecutionParams.<span class="built_in">AttemptCalculateCapturedAttributeMagnitude</span>(<span class="built_in">DamageStatics</span>().DefensePowerDef, EvaluateParameters, DefensePower);</span><br><span class="line"></span><br><span class="line">   <span class="type">float</span> Damage = -(AttackPower - DefensePower);</span><br><span class="line">   </span><br><span class="line">   OutExecutionOutput.<span class="built_in">AddOutputModifier</span>(<span class="built_in">FGameplayModifierEvaluatedData</span>(<span class="built_in">DamageStatics</span>().HealthProperty, EGameplayModOp::Additive, Damage));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>OutExecutionOutput.AddOutputModifier</strong>()中定义最终要给Target的Modifier</p><h3 id="冷却GE（Cooldown-GamePlayEffect）"><a href="#冷却GE（Cooldown-GamePlayEffect）" class="headerlink" title="冷却GE（Cooldown GamePlayEffect）"></a>冷却GE（Cooldown GamePlayEffect）</h3><hr><p>Cooldown GE是Duration类型的GE，没有Modifier，但需要赋予自身ASC一个“<em>Cooldown.xxx.xxx</em>”的tag。可以通过以下三种方式之一实现冷却时间和Tag的配置：</p><ul><li>直接配置在单个CooldownGameplayEffect的Modifier中（固定值），这样比较直观但灵活性差。</li><li>用<a href="https://km.netease.com/article/395325#SetByCaller">SetByCaller</a>，配置tag“<em>Data.Cooldown</em>”对应的数值来设定技能的冷却时间。并且需要重写UGameplayAbility::GetCooldownTags()和UGameplayAbility::ApplyCooldown()</li></ul><p>具体用法：把CoolDown GE的持续时间设置为Set By Caller，overrider ApplyCooldown函数，将CoolDown GE的持续时间设置为自定义的值。SpecHandle.Data.Get()-&gt;SetSetByCallerMagnitude可以完成自定义值的设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void UBaseGameplayAbility::ApplyCooldown(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo) const</span><br><span class="line">&#123;</span><br><span class="line">UGameplayEffect* CooldownGE = GetCooldownGameplayEffect();</span><br><span class="line">if (CooldownGE)</span><br><span class="line">&#123;</span><br><span class="line">FGameplayEffectSpecHandle SpecHandle = MakeOutgoingGameplayEffectSpec(CooldownGE-&gt;GetClass(), GetAbilityLevel());</span><br><span class="line">SpecHandle.Data.Get()-&gt;SetSetByCallerMagnitude(CooldownTag, CooldownDuration.GetValueAtLevel(GetAbilityLevel()));</span><br><span class="line">ApplyGameplayEffectSpecToOwner(Handle, ActorInfo, ActivationInfo, SpecHandle);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cooldown GamePlay SetSetByCallerMagnitude</p><ul><li>在Modifier中自定义MMC，在MMC中获取Ability中设定的冷却时间。并且需要重写UGameplayAbility::GetCooldownTags()和UGameplayAbility::ApplyCooldown()</li></ul><h2 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h2><p>Attribute是由FGameplayAttributeData结构体定义的浮点值，其可以表示从角色生命值到角色等级再到一瓶药水的剂量的任何事物，如果某项数值是属于某个Actor且游戏相关的，你就应该考虑使用Attribute。Attribute一般应该只能由GE修改，这样ASC才能预测(Predict)其改变。一般Attribute需要由AttributeSet进行保存和管理，而AttributeSet注册于ASC中并受其管理，因此Attribute的访问一般也是通过ASC完成的。</p><p>每个Attribute都有一个BaseValue和CurrentValue，需要格外注意的是<strong>BaseValue</strong>不是<strong>CurrentValue</strong>的最大值！CurrentValue用于那些有持续时间的GE造成的Attribute更改，当GE消失时CurrentValue会变回BaseValue（比如加速减速）；而BaseValue处理的是一次性、永久生效的效果，因此生命值受到伤害时，改变的是BaseValue而不是CurrentValue。<strong>更具体的，BaseValue受Instant和Periodic类GE的影响，而CurrentValue受Duration和Infinite类GE影响。(注：CurrentValue受Duration和Infinite影响的提前是没有定义为Period，如果定义了Period，则Duration的GE为视为多个Instant GE的组合，其对BaseValue的修改和GameplayCue的执行方式如同Instant类。)</strong></p><h3 id="Attribute的监听和修改相关函数"><a href="#Attribute的监听和修改相关函数" class="headerlink" title="Attribute的监听和修改相关函数"></a>Attribute的监听和修改相关函数</h3><p>Attribute的修改最好是都通过GE来完成，这样一来可以有效地触发回调函数，而且在实现客户端预测时，也有办法把错误判断修改的数值进行回退。以下是几种常用的监听Attribute变化的方式：</p><ul><li>数值变化生效前，会调用**UAttributeSet::PreAttributeChange(const FGameplayAttribute&amp; Attribute, float&amp; NewValue)**，需要对数值限值的话在此处完成，<a href="http://github.com/tranek/GASDocumentation#445-preattributechange">参考范例</a>。建议该函数内只做限值，不处理游戏逻辑。</li><li>由GE引起的数值变化生效后，但在同步至客户端之前，会调用**UAttributeSet::PostGameplayEffectExecute(const FGameplayEffectModCallbackData &amp; Data)**，可<a href="https://github.com/tranek/GASDocumentation/blob/549f1955a21504ffdf318464897d686db5bb8e68/Source/GASDocumentation/Private/Characters/Abilities/AttributeSets/GDAttributeSetBase.cpp#L45">参考范例</a>。在Data中可以获取GE相关的各种信息，因此可以处理各种GE作用后的逻辑，比如伤害的生效。由于数值还没同步到客户端，因此进一步限值需要在此完成，比如限制Health不能小于0。</li><li>在ASC中绑定委托和回调函数，实现Attribute的监听，如下所示。此处一般处理与数值无关的一些逻辑，比如通过委托进一步触发受击动作、UI变化等逻辑。(FOnAttributeChangeData为struct类型，无法直接暴露到蓝图中（不能直接使用BlueprintImplementableEvent），可考虑自定义委托然后在PostGameplayEffectExecute中直接广播)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AbilitySystemComponent-&gt;<span class="built_in">GetGameplayAttributeValueChangeDelegate</span>(AttributeSetBase-&gt;<span class="built_in">GetHealthAttribute</span>()).<span class="built_in">AddUObject</span>(<span class="keyword">this</span>, &amp;AGDPlayerState::HealthChanged);</span><br><span class="line"><span class="comment">// 定义血量变化时的回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AGDPlayerState::HealthChanged</span><span class="params">(<span class="type">const</span> FOnAttributeChangeData&amp; Data)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="Ability-Task"><a href="#Ability-Task" class="headerlink" title="Ability Task"></a>Ability Task</h2><h3 id="自定义AbilityTask"><a href="#自定义AbilityTask" class="headerlink" title="自定义AbilityTask"></a>自定义AbilityTask</h3><p>通常你需要创建自己的自定义<code>AbilityTask</code>(C++中). 样例项目带有两个自定义<code>AbilityTask</code>:</p><ol><li><code>PlayMontageAndWaitForEvent</code>是默认<code>PlayMontageAndWait</code>和<code>WaitGameplayEvent</code>AbilityTask的结合体, 其允许动画蒙太奇自<code>AnimNotify</code>发送GameplayEvent回到启动它的<code>GameplayAbility</code>, 可以使用该Task在动画蒙太奇的某个特定时刻来触发操作.</li><li><code>WaitReceiveDamage</code>可以监听<code>OwnerActor</code>接收伤害. 当英雄接收到一个伤害实例时, 被动护甲层<code>GameplayAbility</code>就会移除一层护甲.</li></ol><p><code>AbilityTask</code>的组成:</p><ul><li>创建新的<code>AbilityTask</code>实例的静态函数</li><li>当<code>AbilityTask</code>完成目的时分发的委托(Delegate)</li><li>进行主要工作的<code>Activate()</code>函数, 绑定到外部的委托等等</li><li>进行清理工作的<code>OnDestroy()</code>函数, 包括其绑定到外部的委托</li><li>所有绑定到外部委托的回调函数</li><li>成员变量和所有内部辅助函数</li></ul><p><strong>Note:</strong> <strong><code>AbilityTask</code>只能声明一种类型的输出委托, 所有的输出委托都必须是该种类型, 不管它们是否使用参数. 对于未使用的委托参数会传递默认值.</strong></p><h4 id="在GA中实现Tick节点"><a href="#在GA中实现Tick节点" class="headerlink" title="在GA中实现Tick节点"></a>在GA中实现Tick节点</h4><ul><li>继承UAbilityTask，设置bTickingTask&#x3D;true</li><li>新建一种委托，可以在蓝图中实现委托函数</li><li>利用static函数new当前的AbilityTask对象</li><li>override TickTask，广播委托</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam</span>(FOnTickDelegate, <span class="type">float</span>, DeltaTime);</span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UETEST_API</span> UAbilityTask_AbilityTick : <span class="keyword">public</span> UAbilityTask</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">GENERATED_BODY</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">UAbilityTask_AbilityTick</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">UFUNCTION</span>(BlueprintCallable, Category = <span class="string">&quot;Ability|Tasks&quot;</span>, meta = (HidePin = <span class="string">&quot;OwningAbility&quot;</span>, DefaultToSelf = <span class="string">&quot;OwningAbility&quot;</span>, BlueprintInternalUseOnly = <span class="string">&quot;TRUE&quot;</span>))</span><br><span class="line"><span class="function"><span class="type">static</span> UAbilityTask_AbilityTick* <span class="title">AbilityTick</span><span class="params">(UGameplayAbility* OwningAbility)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UPROPERTY</span>(BlueprintAssignable)</span><br><span class="line">FOnTickDelegate OnTickDelegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">/** Tick function for this task, if bTickingTask == true */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TickTask</span><span class="params">(<span class="type">float</span> DeltaTime)</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnDestroy</span><span class="params">(<span class="type">bool</span> AbilityIsEnding)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">UAbilityTask_AbilityTick::UAbilityTask_AbilityTick()</span><br><span class="line">&#123;</span><br><span class="line">bTickingTask = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UAbilityTask_AbilityTick::TickTask(float DeltaTime)</span><br><span class="line">&#123;</span><br><span class="line">Super::TickTask(DeltaTime);</span><br><span class="line">OnTickDelegate.Broadcast(DeltaTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UAbilityTask_AbilityTick* UAbilityTask_AbilityTick::AbilityTick(UGameplayAbility* OwningAbility)</span><br><span class="line">&#123;</span><br><span class="line">UAbilityTask_AbilityTick* MyObj = NewAbilityTask&lt;UAbilityTask_AbilityTick&gt;(OwningAbility);</span><br><span class="line">return MyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Note:</p><ul><li>在多人游戏中使用mesh的PlayMontage不能自动同步蒙太奇，需要使用GAS自带的PlayMontageAndWait(AbilityTask)才能同步蒙太奇</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Game Play </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE_Advanced ARPG Melee Combat System学习笔记</title>
      <link href="/2022/02/20/UE_Advanced%20ARPG%20Melee%20Combat%20System%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/20/UE_Advanced%20ARPG%20Melee%20Combat%20System%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="CharacterStateManagerComponent"><a href="#CharacterStateManagerComponent" class="headerlink" title="CharacterStateManagerComponent"></a>CharacterStateManagerComponent</h3><p><strong>Function</strong></p><ul><li>SetAction(设置动作，不包括动画)</li><li>SetState</li></ul><p><strong>Event</strong></p><ul><li>Action Begin (在设置动作开始时触发，主要包括镜头等处理)</li><li>Action End</li></ul><h3 id="MontageManagerComponent"><a href="#MontageManagerComponent" class="headerlink" title="MontageManagerComponent"></a>MontageManagerComponent</h3><p><strong>Function</strong></p><ul><li>GetGeneralActionMontage</li><li>SetState</li></ul><h3 id="CollisionComponent"><a href="#CollisionComponent" class="headerlink" title="CollisionComponent"></a>CollisionComponent</h3><p><strong>Event</strong></p><ul><li>OnCollisionEnable （打开碰撞检测，触发CollisionTrace事件）</li><li>CollisionTrace （循环检测碰撞直到EnableCollisionTrace被设置成false，循环期间根据碰撞信息触发OnHit事件，OnHit事件的具体逻辑由角色蓝图进行控制）</li></ul><h4 id="InputBufferNS-AnimNotifyState"><a href="#InputBufferNS-AnimNotifyState" class="headerlink" title="InputBufferNS:  AnimNotifyState"></a>InputBufferNS:  AnimNotifyState</h4><p>该类配合动画Montage中的Nofities来控制特定动作时间内才允许接受玩家输入</p><p><strong>Function</strong></p><ul><li>Received_NotifyBegin</li><li>Received_NotifyEnd</li></ul><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/2.png?raw=true" alt="image-20211227155216998"></p><p>攻击动画蒙太奇的配置</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/3.png?raw=true" alt="image-20211227165119510"></p><p>InputBufferNS控制玩家输入缓存</p><h4 id="AttackTraceNS：AnimNotifyState"><a href="#AttackTraceNS：AnimNotifyState" class="headerlink" title="AttackTraceNS：AnimNotifyState"></a>AttackTraceNS：AnimNotifyState</h4><p>该类配合动画Montage中的Nofities来控制攻击过程中的碰撞体</p><p><strong>Function</strong></p><ul><li>Received_NotifyBegin</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（1）根据类型执行相关逻辑</span><br><span class="line">（2）如果是武器，获取当前武器和武器碰撞体的相关信息，调用武器CollisionComponent中的Enable Collision事件（开启碰撞检测，清除之前的碰撞信息）</span><br><span class="line">（3）如果是四肢，打开四肢的碰撞体</span><br><span class="line">（4）如果是盾牌，打开盾牌的碰撞体</span><br></pre></td></tr></table></figure><ul><li>Received_NotifyEnd(关闭碰撞体)</li></ul><p><strong>攻击动画蒙太奇的整体流程：</strong></p><p>初始化过程中就会将主角Actor中的碰撞体引用绑定到Collision Component上</p><ul><li>（1）动画蒙太奇配置AttackTraceNS(AnimNotifyState)，Received_NotifyBegin调用角色实现的CombatBPI接口存储此次攻击信息（Update Attack Info），同时打开武器碰撞体检测，打开期间根据循环检测是否碰撞</li><li>（2）检测通过MultiSphereTraceForObject函数，将检测结果放入HItActors数组中</li><li>（3）处理碰撞结果，调用OnHit事件，主要是根据碰撞信息和人物攻击力等数值信息播放受击动画、特效，造成伤害等</li><li>（4）AttackTraceNS的Received_NotifyEnd关闭武器碰撞体</li></ul><p>AI的攻击蒙太奇主要靠Attack_Trace_AI实现</p><p><strong>碰撞检测造成伤害流程</strong></p><p>攻击蒙太奇中开启碰撞检测，产生碰撞结果后会调用当前持有Collision Componet的Actor的On Hit事件，</p><p>武器的On Hit事件</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/4.png?raw=true" alt="image-20211230150356776"></p><p>如果被击中的Actor是Pawn，则执行<strong>Try to Apply Damge</strong>（在服务端运行，Try to Apply Damge中根据武器的自身设置和持有武器的Actor调用UE中自带的Actor伤害系统（Apply Damage函数）），然后调用持有武器Actor 的On Hit事件。</p><p>如果Actor不是Pawn则调用武器持有者的On Hit事件</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/5.png?raw=true" alt="image-20211230152953540"></p><p>主角Actor的On Hit事件会调用<strong>On Melee Hit</strong>事件：</p><ul><li><p>获取动画蒙太奇中配置的Attack Info</p></li><li><p>获取被攻击者的Hit React Component</p></li><li><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/6.png?raw=true"></p><p><strong>Make Combat Hit Data</strong>中计算两者距离、攻击方向、调用受击者的Get Impact Decision得到当前是否格挡，<strong>Store CombitHit Data</strong>将受击信息（CombatHitData_Struct）存储到受击者的Hit Reaction Component中，后面的受击者的伤害计算、受击反馈等需要使用该数据</p></li><li><p>在被攻击者的Hit React Component的设置碰撞信息，包括碰撞骨骼，碰撞位置等</p></li><li><p>伤害计算后攻击者通过Apply Damage传递攻击的相关数据，被攻击者接收Event AnyDamage事件处理伤害<img src="https://github.com/nevermorec/Photo-store/blob/master/All/7.png?raw=true" alt="image-20211230171903467"></p></li><li><p>调用被攻击者Hit React Component播放受击动画、特效等</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/8.png?raw=true" alt="image-20220113190346003"></p></li></ul><p><strong>普攻连击流程：</strong></p><p>MontageComponent中的DataTable中引用了CombatMontagesDataTable，该表格存储了一套动作连招的所有蒙太奇。</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/9.png?raw=true" alt="image-20211230115943728"></p><p>执行普通攻击的入口：</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/10.png?raw=true" alt="image-20211230114554643"></p><p>Attack Type类型包括Light attack、strong attack等枚举类型</p><ul><li>设置CombatComponet中的attack type</li><li>设置CharacterStateManager中的Action(这里是Attack，CharacterStateManager会处理新旧Action切换的一些行为)</li><li>设置CharacterStateManager中的State(这里是Attacking，CharacterStateManager会处理新旧State切换的一些行为)</li><li>清除ResetAttackHandle计时器（计时器的作用是重置当前的Attack Count，这里的清除作用是允许角色继续连击，增加Attack Count）</li><li>根据Attack Type和Attack Index获取要执行的蒙太奇</li><li>Inform AI  of An Attack通知相关AI角色要执行的动作，供AI后续执行自己的处理</li><li>播放动画蒙太奇</li><li>Attack Count++，如果Attack Count没有被重置下次执行Perform Attack则会索引到下一个配置好的蒙太奇动画</li><li>设置重置Attack Count的定时器（demo这里设置为蒙太奇时间*0.8）</li><li>检测蒙太奇是否播放成功，成功则执行StatsComponent中的Modify Current Stat Value扣除法力，耐力等逻辑</li></ul><p>ARPG的连击方法：</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/11.png?raw=true" alt="image-20220113191554301"></p><p>JumpSectionNS 期间内可以连击， JumpSections 存储了可以跳转的Section</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/12.png?raw=true" alt="image-20220113201350324"></p><p>期间在此触发相同普攻，会依据 JumpSections设置的 JumpSections来跳转到指定section。</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/13.png?raw=true" alt="image-20220113201941101"></p><p><strong>基础设定</strong></p><p>Character State：</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/14.png?raw=true" alt="image-20211230145253302"></p><p>Character Action：</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/15.png?raw=true" alt="image-20211230145345422"></p><p><strong>Get General Action Montage</strong>：</p><p>得到当前要播放的蒙太奇动画</p><p>每次更新武器会替换当前的Switch weapon的蒙太奇动画</p><p>蒙太奇动画管理：</p><p>不同武器之间对应不同的蒙太奇动画，需要在切换武器时切换当前角色的蒙太奇动画</p><p><strong>CombatMontagesDataTable</strong>数据表中存储了不同武器下的蒙太奇动画（装备武器、攻击、翻滚动作、受击反馈动画等等）</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/16.png?raw=true"></p><p>当触发EquipmentManagerComponent中的OnCombatTypeChange事件（武器该表）时，调用MonatgeManagerComponent中的UpdateMontage函数处理蒙太奇动画的更新。</p><p>多角色蒙太奇配合：</p><p>以暗杀为例，暗杀需要两个角色配合表演完整的暗杀动画。</p><p>暗杀者通过向前的碰撞检测敌人，如果有敌人检查是否满足暗杀条件，条件成功执行暗杀，并且将被暗杀者的背板值General AI State设置为Assasinated，通过被暗杀者的行为树控制表演被杀动画。</p><p><strong>AI</strong></p><p>AI的行为树分为一下几个部分：</p><ul><li>进入战斗（播放装备武器动画、修改General AI State）</li><li>退出战斗</li><li>巡逻</li><li>战斗</li></ul><p>服务节点：BTS_AIDecisionMaker，</p><p>战斗子行为树的实现：</p><p>服务节点：BTS_TrackPlayerState，该服务设置当前角色的AI Action，包括Attack、Block、Dodge、Hit等，叶子节点负责执行对应的AI Action</p><p>攻击Task节点：根据BTS_AIDecisionMaker设置的攻击方式进行攻击</p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>继承SaveGame，在类中自定义需要存储的数据</p><p>在GameInstance中新建变量CurSavedGame，变量类型是上面的类</p><p><strong>载入数据</strong>：</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/17.png?raw=true" alt="image-20220124095618894"></p><p><strong>保存数据到文件：</strong></p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/18.png?raw=true" alt="image-20220124095715901"></p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/19.png?raw=true" alt="image-20220124095749898"></p><p>Save Game to Slot会创建一个(Slot Name).sav的文件，本地保存路径为Saved&#x2F;SavedGame&#x2F;(Slot Name).sav</p>]]></content>
      
      
      
        <tags>
            
            <tag> UE,GAMEPLAY </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE-AI</title>
      <link href="/2022/01/20/UE-AI/"/>
      <url>/2022/01/20/UE-AI/</url>
      
        <content type="html"><![CDATA[<p>UE的一个AI一般包括一下几个部分：</p><ul><li><strong>Pawn:</strong> Pawn为AI角色；</li><li><strong>AI Controller:</strong>  AI Controller用于操控Pawn（与玩家的Palyer Controller相对应）；</li><li><strong>Behavior Tree:</strong>  行为树依据不用的情况来操纵AI Controller；</li><li><strong>Black Board</strong>:  黑板用于记录一系列变量数据，给行为树的决策提供依据。</li><li><strong>AI Perception</strong>: AI感知是actor component ，用于提供视觉，听觉，触觉等等感知，一般添加到AI Controller中</li></ul><p>UE4行为树由事件驱动，可以通过条件装饰器观察数值，并且在可以中止其他节点。</p><h3 id="AI-感知"><a href="#AI-感知" class="headerlink" title="AI 感知"></a>AI 感知</h3><p>默认的AI Perception Component提供了视觉、听觉的配置，可视觉配置的属性如下，可以配置AI 可视半径，可视角度等一系列属性。</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/AI/1.png?raw=true"></p><p>AI感知玩家并且设置黑板相关变量的简单例子：</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/AI/2.png?raw=true"></p><p>如果需要定义特定的AI感知，可以继承UAISense类来实现特定感知。</p><h3 id="服务节点"><a href="#服务节点" class="headerlink" title="服务节点"></a>服务节点</h3><p>服务节点是UE行为树的一种特殊功能，继承BTService_BlueprintBase，用于增加到Task节点或者复合节点，只要子节点在运行，服务节点就会以固定的频率tick，可以实现类似传统树的并行复合节点的功能，服务节点通过override Event Tick AI函数来实现特定的服务逻辑</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/AI/3.png?raw=true" alt="image-20220113184805288"></p><h3 id="场景查询系统（EQS）"><a href="#场景查询系统（EQS）" class="headerlink" title="场景查询系统（EQS）"></a>场景查询系统（EQS）</h3><p><strong>场景查询系统（EQS）</strong> 是UE4 AI系统的一个功能，可将其用于从环境中收集数据。在EQS中，可以通过不同种类的测试向收集的数据提问，这些测试会根据提出问题的类型来生成最适合的项目。</p><p>一次场景查询主要包括以下部分：</p><ul><li><strong>生成器（Generator）</strong>，用于生成位置或actor，生成的东西被称为项目（item）</li><li><strong>测试（Test）</strong>，为所有的item打分（过滤），最终可以得到最佳的item</li><li><strong>情景（Context）</strong>，为各种测试和生成器提供引用，例如为距离测试提供一个衡量距离的Actor</li></ul><p><strong>生成器</strong>：</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/AI/4.png?raw=true"></p><p>Actors of Class 生成一定范围内的actor作为item</p><p>Composite：合并多个生成器的结果</p><p>Points ：生成一定范围的点作为item</p><p><strong>Test</strong>：分为过滤测试（Filter）和评分（Socre）测试两类，过滤测试会移除未通过的item，评分测试会对所有的item评分，UE4中永远先进行过滤再进行评分。</p><p>UE中自带的测试包括距离测试、寻路测试、Trace测试等等，可以通过C++代码创建自定义测试。</p><p><strong>Context</strong>：为生成器和测试提供指定Context，一般用于提供特定的点或者特定的Actor</p><p>在生成器类型的 Details 面板中，可以将查询器指定为下列属性的情境，例如在Points:Grid生成器中，生成中心默认是查询者Actor自身，也可以指定为一个Context的actor</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/AI/5.png?raw=true"></p><p>新建一个Context：</p><ul><li>创建 <strong>EnvQueryContext_BlueprintBase</strong> 类的新蓝图</li><li>override Provide Single Location或Provide Single Actor函数</li></ul><h4 id="EQS调试"><a href="#EQS调试" class="headerlink" title="EQS调试"></a>EQS调试</h4><p><img src="https://github.com/nevermorec/Photo-store/blob/master/AI/6.png?raw=true" alt="image-20220105153536733"></p><p>单引号(‘)按键打开AI相关调试信息，默认是小键盘数字键1 2 3 4开关对应的调试信息，如果没有小键盘需要的project setting的gameplay debugger中修改按键</p><p>打开EQS调试，地面会标记当前EQS的查询结果，根据Environment Query规则给可选点进行打分，最终得到各个点的分值。</p><p><strong>EQSTestPawn</strong>：可用于在编辑器中调试EQS查询结果，图中显示了特定点在周围的得分，该规则是过滤看不到右下角玩家的点，距离当前位置越近得分越高，该规则可以筛选出可以看到指定玩家最近的点。</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/AI/7.png?raw=true" alt="image-20220105155823116"></p><p>用法：</p><ul><li><p>创建EQSTestingPawn类型的蓝图</p></li><li><p>设置EQSTestingPawn的Query Template为指定的查询规则</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/AI/8.png?raw=true" alt="image-20220117203904063"></p></li></ul><h3 id="AI-寻路"><a href="#AI-寻路" class="headerlink" title="AI 寻路"></a>AI 寻路</h3><h4 id="导航区域类型设置"><a href="#导航区域类型设置" class="headerlink" title="导航区域类型设置"></a>导航区域类型设置</h4><p>Nav Modifier Volume可以在地图中为Cube指定区域的类型，默认的类型如下：</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/AI/9.png?raw=true" alt="image-20220224144528524"></p><p>Nav_null意味着不可走， Nav_Obstacle意味将指定相较于默认值 NavArea_Default更高的成本，寻路会尽可能避开该区域，除非代理找不到成本更低的路径。</p><p>可以通过继承<strong>Nav Area</strong>来实现自定的区域类型，修改<strong>默认成本（Default Cost）</strong> 乘数和 <strong>固定区域进入成本（Fixed Area Entering Cost）</strong>来实现自定义区域属性。</p><h4 id="寻路查询筛选器（Navigation-Query-Filter）"><a href="#寻路查询筛选器（Navigation-Query-Filter）" class="headerlink" title="寻路查询筛选器（Navigation Query Filter）"></a>寻路查询筛选器（Navigation Query Filter）</h4><p>创建BP继承<strong>Navigation Query Filter</strong>，可以自定义所有导航区域的Cost，实现自定义导航路径的目的。</p><p>使用寻路查询筛选器的方式：</p><ul><li><p>在Ai Controller 的Class Default设置默认的Filter</p></li><li><p>获取Controller，调用Move To函数</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/AI/10.png?raw=true" alt="image-20220224151549030"></p></li></ul><h4 id="Navmesh生成的三种方式："><a href="#Navmesh生成的三种方式：" class="headerlink" title="Navmesh生成的三种方式："></a>Navmesh生成的三种方式：</h4><ul><li><strong>Static</strong>， 寻路网格体离线生成，随关卡保存。寻路网格体在运行时加载，无法更改。</li><li><strong>Dynamic</strong>，运行时动态生成，可以设置tick的时间</li><li><strong>Dynamic Modifiers Only</strong>， 在运行时，只有寻路区域、寻路链接和动态对象之类的寻路修饰可以通过更改成本或阻挡区域来修改现有寻路网格体。在运行时不会生成新的寻路网格体表面。</li></ul><p>以上生成方式可以在Project Setting或者recast中设置</p><p><strong>Nav Modifier</strong>组件可以在运行时动态的修改NavMesh生成的网格，在Actor中添加<strong>Nav Modifier</strong>组件，可以设置Actor的区域类型， 不过运行修改的特性仅支持Dynamic Modifiers Only和Dynamic的网格生成方式。</p><p><strong>设置（Settings） &gt; 项目设置（Project Settings）</strong>，并转到 <strong>寻路系统（Navigation System）</strong> 类别。启用 <strong>仅在寻路调用程序周围生成寻路（Generate Navigation Only Around Navigation Invokers）</strong> 复选框，启用后配合动态生成方式可以仅在添加了Navigation Invoker的Actor的周围生成寻路网格，无需在编辑器中构建寻路网格，而是在运行时在代理周围生成寻路网格。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="Nav-Link-Proxy"><a href="#Nav-Link-Proxy" class="headerlink" title="Nav Link Proxy"></a>Nav Link Proxy</h3><p>功能是在两个点之间创建Navmesh可以识别的连接，可以用于AI通过障碍物等特定地形的导航。</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/AI/11.png?raw=true" alt="image-20220121152252936"></p><p>Link类型：</p><ul><li><strong>SimpleLink</strong>，可以识别到连接，但是Agent不一定能够通过，例如无法实现从下往上跳跃的过程</li><li><strong>SmartLink</strong>，通过Event Receive SmartLink Reached来实现自定义AI速度、Play Montage等功能</li></ul><p>SmartLink实现跳跃的例子：</p><p><img src="https://github.com/nevermorec/Photo-store/blob/master/AI/12.png?raw=true"></p><p>Link可以指定通过方向</p><p>可以结合NavArea 、NavQueryFilter，标记实现不同Nav Link的Enable Nav Area，只允许特定的Nav Area拥有该连接信息，然后通过NavQueryFilter指定包括或者排除特定Nav Area，在路径选择过程中指定NavFilter，可以实现不同AI有不同的导航地图，不同的跳跃能力</p><p><a href="https://www.youtube.com/watch?v=5pMRqcRjC1k">https://www.youtube.com/watch?v=5pMRqcRjC1k</a></p><p><a href="https://www.youtube.com/watch?v=ECys4U2fOKs&amp;list=PL4G2bSPE_8ukuajpXPlAE47Yez7EAyKMu&amp;index=12">https://www.youtube.com/watch?v=ECys4U2fOKs&amp;list=PL4G2bSPE_8ukuajpXPlAE47Yez7EAyKMu&amp;index=12</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> AI,UE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity IK脚保持始终在地面</title>
      <link href="/2021/12/11/Unity%20IK%E8%84%9A%E4%BF%9D%E6%8C%81%E5%A7%8B%E7%BB%88%E5%9C%A8%E5%9C%B0%E9%9D%A2/"/>
      <url>/2021/12/11/Unity%20IK%E8%84%9A%E4%BF%9D%E6%8C%81%E5%A7%8B%E7%BB%88%E5%9C%A8%E5%9C%B0%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="Unity时间函数执行顺序"><a href="#Unity时间函数执行顺序" class="headerlink" title="Unity时间函数执行顺序"></a>Unity时间函数执行顺序</h2><p><img src="https://github.com/nevermorec/Photo-store/blob/master/All/1.png?raw=true"></p><p>上图是Unity中部分时间函数的执行顺序，大致是Update()、协程事件、动画事件、LateUpdate()，在使用IK过程中需要注意事件函数的更新顺序，不然修改的数据很可能无效。例如如果在Update中修改人体关节的位置，会因为动画事件的关节位置再次修改而导致之前的修改无效，所以更新人体关节的操作可以放在LateUpate中。</p><h2 id="脚部IK的实现思路"><a href="#脚部IK的实现思路" class="headerlink" title="脚部IK的实现思路"></a>脚部IK的实现思路</h2><p>脚部IK主要控制角色脚的Position和Rotaion</p><ul><li>（1）通过射线检测计算左右脚离地距离、地面法线、地面位置</li><li>（2）判断脚是否接触地面（或者在地面以下），接触地面的脚需要使用地面法线、地面位置来修改脚部IK</li><li>（3）如果是单脚接触地面的情况，需要下移臀部使得另一只脚也能够尽可能的在地面上</li></ul><p>IK的位置需要在OnAnimatorIK中设置，臀部关节的设置需要在LateUpdate中；</p><p>为了避免脚趾穿模，可以增加一些射线检测来避免；</p><p>为了更好的移动效果，臀部关节的偏移可以加上插值</p><h4 id="脚部IK的实现代码"><a href="#脚部IK的实现代码" class="headerlink" title="脚部IK的实现代码"></a>脚部IK的实现代码</h4><p>参考UTPM实现了一个脚步IK的功能</p><ul><li>数据</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Transform m_Transform;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Transform m_Hips;</span><br><span class="line"><span class="keyword">private</span> Vector3 m_HipsLocalPosition;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span> m_HipsOffset;</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span>[] groundDistance = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">2</span>]; <span class="comment">// 地面距离</span></span><br><span class="line">Vector3[] groundPoint = <span class="keyword">new</span> Vector3[<span class="number">2</span>]; <span class="comment">// 地面接触点</span></span><br><span class="line">Vector3[] groundNormal = <span class="keyword">new</span> Vector3[<span class="number">2</span>]; <span class="comment">// 射线检测法线</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">SerializeField</span>] </span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">float</span> m_HipsPositionAdjustmentSpeed = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> player m_Player;</span><br><span class="line"><span class="keyword">public</span> FullBodyBipedIK ik;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="built_in">float</span> m_FootOffsetAdjustment = <span class="number">0.005f</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span>[] m_LegLength = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">float</span>[] m_FootOffset = <span class="keyword">new</span> <span class="built_in">float</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> m_LayerMask;</span><br></pre></td></tr></table></figure><ul><li>AnimatorIk</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnAnimatorIK</span>(<span class="params"><span class="built_in">int</span> layerIndex</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    HandleLowerIK();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update is called once per frame</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleLowerIK</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> hipsOffset = m_Player.c_ColliderSpacing;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算地面距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 legPos = (i == <span class="number">0</span>) ? ik.references.leftCalf.position : ik.references.rightCalf.position;</span><br><span class="line">        Vector3 feetPos = (i == <span class="number">0</span>) ? ik.references.leftFoot.position : ik.references.rightFoot.position;</span><br><span class="line">        <span class="keyword">var</span> raycastStartPoint = GetFootRaycastPosition(feetPos, legPos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> m_RaycastHit = <span class="keyword">new</span> RaycastHit();</span><br><span class="line">        <span class="keyword">if</span> (Physics.Raycast(raycastStartPoint, -m_Transform.up, <span class="keyword">out</span> m_RaycastHit, </span><br><span class="line">                            <span class="number">2</span> * m_LegLength[i] + m_FootOffset[i] + m_FootOffsetAdjustment, m_LayerMask, QueryTriggerInteraction.Ignore))</span><br><span class="line">        &#123;</span><br><span class="line">            groundDistance[i] = m_RaycastHit.distance;</span><br><span class="line">            groundPoint[i] = m_RaycastHit.point;</span><br><span class="line">            groundNormal[i] = m_RaycastHit.normal;</span><br><span class="line"></span><br><span class="line">            UpdateHipsOffset(groundDistance[i], i, <span class="keyword">ref</span> hipsOffset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> groundDistance[i] = <span class="built_in">float</span>.MaxValue;</span><br><span class="line"></span><br><span class="line">        Debug.DrawLine(raycastStartPoint, groundPoint[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Smoothly position the hips.</span></span><br><span class="line">    <span class="keyword">if</span> (m_Player.CheckGround()) </span><br><span class="line">        m_HipsOffset = Mathf.Lerp(m_HipsOffset, hipsOffset, m_HipsPositionAdjustmentSpeed * Time.deltaTime);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        m_HipsOffset = Mathf.Lerp(m_HipsOffset, <span class="number">0</span>, m_HipsPositionAdjustmentSpeed * Time.deltaTime);</span><br><span class="line">    m_HipsLocalPosition = m_Transform.InverseTransformPoint(m_Hips.position);</span><br><span class="line">    m_HipsLocalPosition.y -= m_HipsOffset;</span><br><span class="line"></span><br><span class="line">    HandleFootIK();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算地面检测的初始位置</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">GetFootRaycastPosition</span>(<span class="params">Vector3 feetPos, Vector3 legPos</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> raycastPosition = m_Transform.InverseTransformPoint(feetPos);</span><br><span class="line">    <span class="keyword">var</span> localHipPosition = m_Transform.InverseTransformPoint(legPos);</span><br><span class="line">    raycastPosition.y = localHipPosition.y;</span><br><span class="line">    <span class="keyword">var</span> result = m_Transform.TransformPoint(raycastPosition);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleFootIK</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// feet</span></span><br><span class="line">        Vector3 legPos = (i == <span class="number">0</span>) ? ik.references.leftCalf.position : ik.references.rightCalf.position;</span><br><span class="line">        <span class="keyword">var</span> footTargetPos = (i == <span class="number">0</span>) ? ik.references.leftFoot.position : ik.references.rightFoot.position;</span><br><span class="line">        <span class="keyword">var</span> footTargetRot = (i == <span class="number">0</span>) ? ik.references.leftFoot.rotation : ik.references.rightFoot.rotation;</span><br><span class="line">        <span class="keyword">var</span> feetIKWeight = <span class="number">0f</span>;</span><br><span class="line">        <span class="keyword">var</span> effector = (i == <span class="number">0</span>) ? ik.solver.leftFootEffector : ik.solver.rightFootEffector;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果脚接触地面，使用脚步IK</span></span><br><span class="line">        <span class="keyword">if</span> (groundDistance[i] != <span class="built_in">float</span>.MaxValue &amp;&amp; groundDistance[i] &gt; <span class="number">0</span> &amp;&amp; </span><br><span class="line">            m_Transform.InverseTransformDirection(footTargetPos - groundPoint[i]).y - m_FootOffset[i] - m_HipsOffset &lt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> localFootTargetPos = m_Transform.InverseTransformPoint(footTargetPos);</span><br><span class="line">            localFootTargetPos.y = m_Transform.InverseTransformPoint(groundPoint[i]).y;</span><br><span class="line">            footTargetPos = m_Transform.TransformPoint(localFootTargetPos) + m_Transform.up * (m_FootOffset[i]);</span><br><span class="line">            footTargetRot = Quaternion.LookRotation(Vector3.Cross(groundNormal[i], footTargetRot * -Vector3.right), m_Transform.up);</span><br><span class="line">            <span class="comment">//rotation = Quaternion.LookRotation(Vector3.Cross(m_GroundNormal[i], rotation * -Vector3.right), m_CharacterLocomotion.Up);</span></span><br><span class="line">            feetIKWeight = <span class="number">1f</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        effector.position = footTargetPos;</span><br><span class="line">        effector.positionWeight = feetIKWeight;</span><br><span class="line">        effector.rotation = footTargetRot;</span><br><span class="line">        effector.rotationWeight = feetIKWeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果一只脚触地没设置臀部offset，使得另一只脚也能够触地</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">UpdateHipsOffset</span>(<span class="params"><span class="built_in">float</span> groundDistance, <span class="built_in">int</span> index, <span class="keyword">ref</span> <span class="built_in">float</span> hipsOffset</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (groundDistance != <span class="built_in">float</span>.MaxValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((groundDistance - m_LegLength[index] - m_FootOffset[index]) &gt; hipsOffset) </span><br><span class="line">        &#123;</span><br><span class="line">            hipsOffset = groundDistance - m_LegLength[index] - m_FootOffset[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>LateUpdate</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LateUpdate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">m_Hips.position = m_Transform.TransformPoint(m_HipsLocalPosition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AStarPathing学习笔记</title>
      <link href="/2021/11/02/AStarPathing%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/02/AStarPathing%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="在寻路中使用动画的Root-Motion"><a href="#在寻路中使用动画的Root-Motion" class="headerlink" title="在寻路中使用动画的Root Motion"></a>在寻路中使用动画的Root Motion</h2><p>直接使用AI Path、Rich AI等脚本控制移动存在的问题：</p><ul><li>运动速度和动作不匹配，会出现滑步</li><li>角色的转向由AI Path直接控制，效果比较生硬</li></ul><p>为了避免这些问题，可以使用RootMotion，将寻路的相关参数传入动画系统和设置相应的参数，通过动画来控制角色的位移。控制的示意图如下：</p><p>![](C:\Users\huangyuancheng\Pictures\屏幕截图 2021-11-17 142816.png)</p><p>A* Pathingfinder Pro提供了MecanimBridge.cs脚本</p><p>以AI Path为例：</p><p>（1）为角色挂载AI Path和MecanimBridge.cs脚本</p><p>（2）为角色添加Animator Controller，Animator Controller需要包含三个float参数（InputMagnitude、X左右的运动速度、Y前后的运动速度），MecanimBridge通过路径计算controller中的参数数据。</p><p>![](C:\Users\huangyuancheng\Pictures\屏幕截图 2021-11-17 145845.png)</p><p>MecanimBridge.cs脚本大致的实现思路：</p><ul><li>关闭AI path中的自动更新位置和旋转</li><li>在OnAnimatorMove()中计算并设置动画参数，同时根据anim.deltaPosition和anim.deltaRotation更新角色移动和旋转</li></ul><p>使用过程中存在的不足：</p><ul><li><p>如果角速度过小会在尖角的特定地形卡住出不来，在实际过程中需要设置较大的角速度或者避免寻路到此点。</p></li><li><p>MecanimBridge.cs如果搭配AI path在角速度较小的情况下会直接直接穿过障碍物（穿模），使用Rich AI则不会。</p></li><li><p>使用Root motion控制位移相当于对路径再次进行处理，还和Animator动画进行关联，导致排查问题会更加困难。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>追踪子弹的实现</title>
      <link href="/2021/10/31/%E8%BF%BD%E8%B8%AA%E5%AD%90%E5%BC%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/10/31/%E8%BF%BD%E8%B8%AA%E5%AD%90%E5%BC%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>要实现一个BOSS可以发射追踪子弹，子弹可以自定义初始方向，需要在子弹运行过程中依据被追踪者的Position动态修改子弹的偏转方向。</p><p>实现思路：</p><p>计算当前距离的方向和子弹的方向的角度，依据转向速度动态修改子弹的rotation</p><p>关键参数：</p><ul><li>float RotSpeed;    &#x2F;&#x2F; 转向速度</li><li>GameObject mEntity;   &#x2F;&#x2F; 追踪Entity的当前Gameobject</li><li>GameObject mTarget;  &#x2F;&#x2F;被追踪者</li></ul><p>实现代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vector3 dir = (mTarget.transform.position + offset -mEntity.transform.position).normalized;</span><br><span class="line"></span><br><span class="line">float a = Vector3.Angle(mEntity.transform.forward, dir) / mRotSpeed;</span><br><span class="line"></span><br><span class="line">// rotate direction</span><br><span class="line">if (a &gt; 0.01f || a &lt; 0.01f)</span><br><span class="line">&#123;</span><br><span class="line">mEntity.transform.forward = Vector3.Slerp(mEntity.transform.forward, dir, fTick / a).normalized;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float dv = mAcc * fTick;</span><br><span class="line">Displace = (mSpeed + 0.5f * dv) * fTick * mEntity.transform.forward;</span><br><span class="line">mSpeed += dv;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Game Play </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Unity上实现按钮点击（短按）和长按操作</title>
      <link href="/2021/08/29/%E5%9C%A8Unity%E4%B8%8A%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%92%AE%E7%82%B9%E5%87%BB%EF%BC%88%E7%9F%AD%E6%8C%89%EF%BC%89%E5%92%8C%E9%95%BF%E6%8C%89%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/08/29/%E5%9C%A8Unity%E4%B8%8A%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%92%AE%E7%82%B9%E5%87%BB%EF%BC%88%E7%9F%AD%E6%8C%89%EF%BC%89%E5%92%8C%E9%95%BF%E6%8C%89%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>在项目中需要完成长按技能显示技能详情的功能，由于Unity的Button只有Click时间，所以button不足以实现这个的功能。</p><p>实现方式：使用图片作为技能显示，通过继承MonoBehaviour,IPointerDownHandler,IPointerUpHandler,IPointerExitHandler接口来获取鼠标在Image上的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 脚本位置：UGUI按钮组件身上</span><br><span class="line">/// 脚本功能：实现角色技能的短按（技能释放）/长按(显示技能详情)状态的判断</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line"> </span><br><span class="line">// 继承：按下，抬起和离开的三个接口</span><br><span class="line">public class OnSkillPressed :MonoBehaviour,IPointerDownHandler,IPointerUpHandler,IPointerExitHandler</span><br><span class="line">&#123;</span><br><span class="line">    public int skillIndex;</span><br><span class="line">    </span><br><span class="line">    // 延迟时间</span><br><span class="line">    private float delay = 0.5f;</span><br><span class="line"> </span><br><span class="line">    // 技能图标是否是按下状态</span><br><span class="line">    private bool isDown = false;</span><br><span class="line">    </span><br><span class="line">    // 技能图标是否已经触发长按操作</span><br><span class="line">    private bool isLongPress = false;</span><br><span class="line"> </span><br><span class="line">    // 按钮最后一次是被按住状态时候的时间</span><br><span class="line">    private float lastIsDownTime;</span><br><span class="line">    </span><br><span class="line">    private GameMsg gameMsg = GameMsg.Instance;</span><br><span class="line"> </span><br><span class="line">    void Update ()</span><br><span class="line">    &#123;</span><br><span class="line">        // 如果按钮是被按下状态</span><br><span class="line">        if (isDown &amp;&amp; (!isLongPress)) &#123;</span><br><span class="line">            // 当前时间 -  按钮最后一次被按下的时间 &gt; 延迟时间0.2秒</span><br><span class="line">            if (Time.time - lastIsDownTime &gt; delay) &#123;</span><br><span class="line">                // 触发长按方法</span><br><span class="line">                isLongPress = true;</span><br><span class="line">                Debug.Log(&quot;长按技能： &quot; + skillIndex.ToString());</span><br><span class="line">                gameMsg.SendMessage(GameMsgType.LongPressSkill, skillIndex);</span><br><span class="line">                // 记录按钮最后一次被按下的时间</span><br><span class="line">                // lastIsDownTime = Time.time; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 当按钮被按下后系统自动调用此方法</span><br><span class="line">    public void OnPointerDown (PointerEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        lastIsDownTime = Time.time;</span><br><span class="line">        isDown = true;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 当按钮抬起的时候自动调用此方法</span><br><span class="line">    public void OnPointerUp (PointerEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        if (Time.time - lastIsDownTime &lt; delay)</span><br><span class="line">        &#123;</span><br><span class="line">            // Debug.Log(&quot;短按技能（显示技能范围）： &quot; + skillIndex.ToString());</span><br><span class="line">            gameMsg.SendMessage(GameMsgType.TapSkill, skillIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            gameMsg.SendMessage(GameMsgType.LongPressSkillCancel);</span><br><span class="line">        &#125;</span><br><span class="line">        isDown = false;</span><br><span class="line">        isLongPress = false;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 当鼠标从按钮上离开的时候自动调用此方法</span><br><span class="line">    public void OnPointerExit (PointerEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        if (isLongPress) gameMsg.SendMessage(GameMsgType.LongPressSkillCancel);</span><br><span class="line">        isDown = false;</span><br><span class="line">        isLongPress = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>简单的UGUI闪烁脚本</title>
      <link href="/2021/08/23/%E7%AE%80%E5%8D%95%E7%9A%84UGUI%E9%97%AA%E7%83%81%E8%84%9A%E6%9C%AC/"/>
      <url>/2021/08/23/%E7%AE%80%E5%8D%95%E7%9A%84UGUI%E9%97%AA%E7%83%81%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>场景：每次释放技能需要在确认前使得要消耗的行动点闪烁</p><p>实现思路：增加CanvasGroup，通过控制alpha值来实现闪烁 </p><p><a href="https://blog.csdn.net/qq_27489007/article/details/83745791">https://blog.csdn.net/qq_27489007/article/details/83745791</a></p><p>脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line"></span><br><span class="line">public class ShanShuoAnim : MonoBehaviour &#123;</span><br><span class="line"> </span><br><span class="line">    private float alpha = 0.2f;</span><br><span class="line">    private float alphaSpeed = 8f;</span><br><span class="line">    private bool isShow = true;//用来控制闪烁的内容</span><br><span class="line">    private CanvasGroup cg;</span><br><span class="line">    private bool isClick = false;//用来控制 彻底不需要走动画了</span><br><span class="line">    private Image shanImg;</span><br><span class="line">    public Sprite shan_sprite;  //外部传进来的</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        cg = this.transform.GetComponent&lt;CanvasGroup&gt;();</span><br><span class="line">        shanImg = this.transform.GetComponent&lt;Image&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if (isClick)</span><br><span class="line">        &#123;</span><br><span class="line">            if (isShow)</span><br><span class="line">            &#123;</span><br><span class="line">                if (alpha != cg.alpha)</span><br><span class="line">                &#123;</span><br><span class="line">                    cg.alpha = Mathf.Lerp(cg.alpha, alpha, alphaSpeed * Time.deltaTime);  //这个方法表示的是一种简便过程 传入初始和想达到的</span><br><span class="line">                    if (Mathf.Abs(alpha - cg.alpha) &lt;= 0.01)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //Debug.Log(&quot;更新2===&quot; + alpha + &quot;===&quot; + cg.alpha);</span><br><span class="line">                        cg.alpha = alpha; isShow = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if (1 != cg.alpha)</span><br><span class="line">                &#123;</span><br><span class="line">                    cg.alpha = Mathf.Lerp(cg.alpha, 1, alphaSpeed * Time.deltaTime);  //这个方法表示的是一种简便过程 传入初始和想达到的</span><br><span class="line">                    if (Mathf.Abs(1 - cg.alpha) &lt;= 0.01)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //Debug.Log(&quot;更新3===&quot; + alpha + &quot;===&quot; + cg.alpha);</span><br><span class="line">                        cg.alpha = 1; isShow = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void ShowAnim()</span><br><span class="line">    &#123;</span><br><span class="line">        //alpha = 1;</span><br><span class="line">        isClick = true;</span><br><span class="line">        shanImg.sprite = shan_sprite;</span><br><span class="line">        //cg.blocksRaycasts = true;//可以和该UI对象交互</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void HideAnim()</span><br><span class="line">    &#123;</span><br><span class="line">        isClick = false;</span><br><span class="line">        //alpha = 0;</span><br><span class="line"> </span><br><span class="line">        //cg.blocksRaycasts = false;//不可以和该UI对象交互</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
