{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"UE_Advanced ARPG Melee Combat System学习笔记","date":"2022-03-04T09:43:56.128Z","updated":"2022-03-04T09:43:42.192Z","comments":true,"path":"2022/03/04/UE_Advanced ARPG Melee Combat System学习笔记/","link":"","permalink":"http://example.com/2022/03/04/UE_Advanced%20ARPG%20Melee%20Combat%20System%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"CharacterStateManagerComponentFunction SetAction(设置动作，不包括动画) SetState Event Action Begin (在设置动作开始时触发，主要包括镜头等处理) Action End MontageManagerComponentFunction GetGeneralActionMontage SetState CollisionComponentEvent OnCollisionEnable （打开碰撞检测，触发CollisionTrace事件） CollisionTrace （循环检测碰撞直到EnableCollisionTrace被设置成false，循环期间根据碰撞信息触发OnHit事件，OnHit事件的具体逻辑由角色蓝图进行控制） InputBufferNS: AnimNotifyState该类配合动画Montage中的Nofities来控制特定动作时间内才允许接受玩家输入 Function Received_NotifyBegin Received_NotifyEnd 攻击动画蒙太奇的配置 InputBufferNS控制玩家输入缓存 AttackTraceNS：AnimNotifyState该类配合动画Montage中的Nofities来控制攻击过程中的碰撞体 Function Received_NotifyBegin 1234（1）根据类型执行相关逻辑（2）如果是武器，获取当前武器和武器碰撞体的相关信息，调用武器CollisionComponent中的Enable Collision事件（开启碰撞检测，清除之前的碰撞信息）（3）如果是四肢，打开四肢的碰撞体（4）如果是盾牌，打开盾牌的碰撞体 Received_NotifyEnd(关闭碰撞体) 攻击动画蒙太奇的整体流程： 初始化过程中就会将主角Actor中的碰撞体引用绑定到Collision Component上 （1）动画蒙太奇配置AttackTraceNS(AnimNotifyState)，Received_NotifyBegin调用角色实现的CombatBPI接口存储此次攻击信息（Update Attack Info），同时打开武器碰撞体检测，打开期间根据循环检测是否碰撞 （2）检测通过MultiSphereTraceForObject函数，将检测结果放入HItActors数组中 （3）处理碰撞结果，调用OnHit事件，主要是根据碰撞信息和人物攻击力等数值信息播放受击动画、特效，造成伤害等 （4）AttackTraceNS的Received_NotifyEnd关闭武器碰撞体 AI的攻击蒙太奇主要靠Attack_Trace_AI实现 碰撞检测造成伤害流程 攻击蒙太奇中开启碰撞检测，产生碰撞结果后会调用当前持有Collision Componet的Actor的On Hit事件， 武器的On Hit事件 如果被击中的Actor是Pawn，则执行Try to Apply Damge（在服务端运行，Try to Apply Damge中根据武器的自身设置和持有武器的Actor调用UE中自带的Actor伤害系统（Apply Damage函数）），然后调用持有武器Actor 的On Hit事件。 如果Actor不是Pawn则调用武器持有者的On Hit事件 主角Actor的On Hit事件会调用On Melee Hit事件： 获取动画蒙太奇中配置的Attack Info 获取被攻击者的Hit React Component Make Combat Hit Data中计算两者距离、攻击方向、调用受击者的Get Impact Decision得到当前是否格挡，Store CombitHit Data将受击信息（CombatHitData_Struct）存储到受击者的Hit Reaction Component中，后面的受击者的伤害计算、受击反馈等需要使用该数据 在被攻击者的Hit React Component的设置碰撞信息，包括碰撞骨骼，碰撞位置等 伤害计算后攻击者通过Apply Damage传递攻击的相关数据，被攻击者接收Event AnyDamage事件处理伤害 调用被攻击者Hit React Component播放受击动画、特效等 普攻连击流程： MontageComponent中的DataTable中引用了CombatMontagesDataTable，该表格存储了一套动作连招的所有蒙太奇。 执行普通攻击的入口： Attack Type类型包括Light attack、strong attack等枚举类型 设置CombatComponet中的attack type 设置CharacterStateManager中的Action(这里是Attack，CharacterStateManager会处理新旧Action切换的一些行为) 设置CharacterStateManager中的State(这里是Attacking，CharacterStateManager会处理新旧State切换的一些行为) 清除ResetAttackHandle计时器（计时器的作用是重置当前的Attack Count，这里的清除作用是允许角色继续连击，增加Attack Count） 根据Attack Type和Attack Index获取要执行的蒙太奇 Inform AI of An Attack通知相关AI角色要执行的动作，供AI后续执行自己的处理 播放动画蒙太奇 Attack Count++，如果Attack Count没有被重置下次执行Perform Attack则会索引到下一个配置好的蒙太奇动画 设置重置Attack Count的定时器（demo这里设置为蒙太奇时间*0.8） 检测蒙太奇是否播放成功，成功则执行StatsComponent中的Modify Current Stat Value扣除法力，耐力等逻辑 ARPG的连击方法： JumpSectionNS 期间内可以连击， JumpSections 存储了可以跳转的Section 期间在此触发相同普攻，会依据 JumpSections设置的 JumpSections来跳转到指定section。 基础设定 Character State： Character Action： Get General Action Montage： 得到当前要播放的蒙太奇动画 每次更新武器会替换当前的Switch weapon的蒙太奇动画 蒙太奇动画管理： 不同武器之间对应不同的蒙太奇动画，需要在切换武器时切换当前角色的蒙太奇动画 CombatMontagesDataTable数据表中存储了不同武器下的蒙太奇动画（装备武器、攻击、翻滚动作、受击反馈动画等等） 当触发EquipmentManagerComponent中的OnCombatTypeChange事件（武器该表）时，调用MonatgeManagerComponent中的UpdateMontage函数处理蒙太奇动画的更新。 多角色蒙太奇配合： 以暗杀为例，暗杀需要两个角色配合表演完整的暗杀动画。 暗杀者通过向前的碰撞检测敌人，如果有敌人检查是否满足暗杀条件，条件成功执行暗杀，并且将被暗杀者的背板值General AI State设置为Assasinated，通过被暗杀者的行为树控制表演被杀动画。 AI AI的行为树分为一下几个部分： 进入战斗（播放装备武器动画、修改General AI State） 退出战斗 巡逻 战斗 服务节点：BTS_AIDecisionMaker， 战斗子行为树的实现： 服务节点：BTS_TrackPlayerState，该服务设置当前角色的AI Action，包括Attack、Block、Dodge、Hit等，叶子节点负责执行对应的AI Action 攻击Task节点：根据BTS_AIDecisionMaker设置的攻击方式进行攻击 数据存储继承SaveGame，在类中自定义需要存储的数据 在GameInstance中新建变量CurSavedGame，变量类型是上面的类 载入数据： 保存数据到文件： Save Game to Slot会创建一个(Slot Name).sav的文件，本地保存路径为Saved&#x2F;SavedGame&#x2F;(Slot Name).sav","categories":[],"tags":[]},{"title":"","slug":"Unity IK脚保持始终在地面","date":"2022-03-04T09:36:38.199Z","updated":"2022-03-04T09:36:01.577Z","comments":true,"path":"2022/03/04/Unity IK脚保持始终在地面/","link":"","permalink":"http://example.com/2022/03/04/Unity%20IK%E8%84%9A%E4%BF%9D%E6%8C%81%E5%A7%8B%E7%BB%88%E5%9C%A8%E5%9C%B0%E9%9D%A2/","excerpt":"","text":"Unity时间函数执行顺序 上图是Unity中部分时间函数的执行顺序，大致是Update()、协程事件、动画事件、LateUpdate()，在使用IK过程中需要注意事件函数的更新顺序，不然修改的数据很可能无效。例如如果在Update中修改人体关节的位置，会因为动画事件的关节位置再次修改而导致之前的修改无效，所以更新人体关节的操作可以放在LateUpate中。 脚部IK的实现思路脚部IK主要控制角色脚的Position和Rotaion （1）通过射线检测计算左右脚离地距离、地面法线、地面位置 （2）判断脚是否接触地面（或者在地面以下），接触地面的脚需要使用地面法线、地面位置来修改脚部IK （3）如果是单脚接触地面的情况，需要下移臀部使得另一只脚也能够尽可能的在地面上 IK的位置需要在OnAnimatorIK中设置，臀部关节的设置需要在LateUpdate中； 为了避免脚趾穿模，可以增加一些射线检测来避免； 为了更好的移动效果，臀部关节的偏移可以加上插值 脚部IK的实现代码参考UTPM实现了一个脚步IK的功能 数据 123456789101112131415161718192021private Transform m_Transform;private Transform m_Hips;private Vector3 m_HipsLocalPosition;private float m_HipsOffset;float[] groundDistance = new float[2]; // 地面距离Vector3[] groundPoint = new Vector3[2]; // 地面接触点Vector3[] groundNormal = new Vector3[2]; // 射线检测法线[SerializeField] protected float m_HipsPositionAdjustmentSpeed = 4;private player m_Player;public FullBodyBipedIK ik;protected float m_FootOffsetAdjustment = 0.005f;private float[] m_LegLength = new float[2];private float[] m_FootOffset = new float[2];private int m_LayerMask; AnimatorIk 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697private void OnAnimatorIK(int layerIndex)&#123; HandleLowerIK();&#125;// Update is called once per frameprivate void HandleLowerIK()&#123; float hipsOffset = m_Player.c_ColliderSpacing; // 计算地面距离 for (int i = 0; i &lt; 2; i++) &#123; Vector3 legPos = (i == 0) ? ik.references.leftCalf.position : ik.references.rightCalf.position; Vector3 feetPos = (i == 0) ? ik.references.leftFoot.position : ik.references.rightFoot.position; var raycastStartPoint = GetFootRaycastPosition(feetPos, legPos); var m_RaycastHit = new RaycastHit(); if (Physics.Raycast(raycastStartPoint, -m_Transform.up, out m_RaycastHit, 2 * m_LegLength[i] + m_FootOffset[i] + m_FootOffsetAdjustment, m_LayerMask, QueryTriggerInteraction.Ignore)) &#123; groundDistance[i] = m_RaycastHit.distance; groundPoint[i] = m_RaycastHit.point; groundNormal[i] = m_RaycastHit.normal; UpdateHipsOffset(groundDistance[i], i, ref hipsOffset); &#125; else groundDistance[i] = float.MaxValue; Debug.DrawLine(raycastStartPoint, groundPoint[i]); &#125; // Smoothly position the hips. if (m_Player.CheckGround()) m_HipsOffset = Mathf.Lerp(m_HipsOffset, hipsOffset, m_HipsPositionAdjustmentSpeed * Time.deltaTime); else m_HipsOffset = Mathf.Lerp(m_HipsOffset, 0, m_HipsPositionAdjustmentSpeed * Time.deltaTime); m_HipsLocalPosition = m_Transform.InverseTransformPoint(m_Hips.position); m_HipsLocalPosition.y -= m_HipsOffset; HandleFootIK();&#125;// 计算地面检测的初始位置private Vector3 GetFootRaycastPosition(Vector3 feetPos, Vector3 legPos)&#123; var raycastPosition = m_Transform.InverseTransformPoint(feetPos); var localHipPosition = m_Transform.InverseTransformPoint(legPos); raycastPosition.y = localHipPosition.y; var result = m_Transform.TransformPoint(raycastPosition); return result;&#125;private void HandleFootIK()&#123; for (int i = 0; i &lt; 2; i++) &#123; // feet Vector3 legPos = (i == 0) ? ik.references.leftCalf.position : ik.references.rightCalf.position; var footTargetPos = (i == 0) ? ik.references.leftFoot.position : ik.references.rightFoot.position; var footTargetRot = (i == 0) ? ik.references.leftFoot.rotation : ik.references.rightFoot.rotation; var feetIKWeight = 0f; var effector = (i == 0) ? ik.solver.leftFootEffector : ik.solver.rightFootEffector; // 如果脚接触地面，使用脚步IK if (groundDistance[i] != float.MaxValue &amp;&amp; groundDistance[i] &gt; 0 &amp;&amp; m_Transform.InverseTransformDirection(footTargetPos - groundPoint[i]).y - m_FootOffset[i] - m_HipsOffset &lt; 0) &#123; var localFootTargetPos = m_Transform.InverseTransformPoint(footTargetPos); localFootTargetPos.y = m_Transform.InverseTransformPoint(groundPoint[i]).y; footTargetPos = m_Transform.TransformPoint(localFootTargetPos) + m_Transform.up * (m_FootOffset[i]); footTargetRot = Quaternion.LookRotation(Vector3.Cross(groundNormal[i], footTargetRot * -Vector3.right), m_Transform.up); //rotation = Quaternion.LookRotation(Vector3.Cross(m_GroundNormal[i], rotation * -Vector3.right), m_CharacterLocomotion.Up); feetIKWeight = 1f; &#125; effector.position = footTargetPos; effector.positionWeight = feetIKWeight; effector.rotation = footTargetRot; effector.rotationWeight = feetIKWeight; &#125;&#125;// 如果一只脚触地没设置臀部offset，使得另一只脚也能够触地private void UpdateHipsOffset(float groundDistance, int index, ref float hipsOffset)&#123; if (groundDistance != float.MaxValue) &#123; if ((groundDistance - m_LegLength[index] - m_FootOffset[index]) &gt; hipsOffset) &#123; hipsOffset = groundDistance - m_LegLength[index] - m_FootOffset[index]; &#125; &#125;&#125; LateUpdate 1234private void LateUpdate()&#123; m_Hips.position = m_Transform.TransformPoint(m_HipsLocalPosition);&#125;","categories":[],"tags":[]},{"title":"","slug":"Slate和行为树接入","date":"2022-03-04T09:25:07.876Z","updated":"2021-12-18T09:23:11.662Z","comments":true,"path":"2022/03/04/Slate和行为树接入/","link":"","permalink":"http://example.com/2022/03/04/Slate%E5%92%8C%E8%A1%8C%E4%B8%BA%E6%A0%91%E6%8E%A5%E5%85%A5/","excerpt":"","text":"Unity Slate插件是一个TimeLine编辑器。支持在时间轴上编辑镜头、Animation、音频、角色IK等各种功能，支持扩展各种自定义节点类型。同时对Node Canvas行为树的支持也非常友好，直接集成了向行为树发送事件节点。 Slate使用界面： 通过添加Cutscene脚本即可编辑TimeLine，一个Slate Editor中可以同时存在多个组（Actor Group），Director为Slate自带的组，其余添加组的属性都带组名和GameObject。一个组内可同时存在多个轨道（Track），一个轨道是一个TImeLine，在TimeLine上可以编辑多个节点（Action Clip）,节点会在对应的时刻触发并执行对应函数。Action Clip为具体的行为片段。例如播放动画、播放特效、发送事件等功能 Slate支持自定义节点，只需要继承实现Action Clip，并且将节点添加到轨道上即可完成触发。 Slate的更新顺序为： Group Enter -&gt; Track Enter -&gt; Clip Enter | ··· Clip Update ··· | Clip Exit -&gt; Track Exit -&gt; Group Exit Slate接入行为树行为树接入Slate主要需要实现： 生成行为树的Task节点用于播放和暂停Slate 行为树和Slate的数据交互（可以通过黑板和事件交互） 序列化Slate数据 下面以Node Canvas行为树为例， 序列化客户端： 方案一可以直接将Cutscene脚本挂载到GameObject，通过序列化Prefab的方式序列化Slate数据。在行为树执行对应Slate Task时，播放Slate只需要初始化GameObject并且调用CutScene的Play方法即可。 方案二可以直接Cutscene的数据序列话成JSON、BSON等格式，运行时反序列化。 服务端：如果需要在服务端执行Slate的逻辑，需要在序列化Slate配置数据，并且在服务端实现Slate的运行逻辑。 生成行为树节点播放Slate由于序列化生成Slate节点无法得到运行时Actor Group的GameObject，需要我们在运行时动态设置。Cutscene中提供了方法SetGroupActorOfName(string groupName, GameObject newActor)，该方法可以通过组名查找替换当前的GameObject。我们可以将Slate需要的Gameobject放在黑板数据中，运行时将黑板GameObject设置到CutScene中即可。 Play Slate的Task节点： 左侧Cutscene为序列化的Slate Prefab，图中Group Name为Actor Group中的组名，New Actor为黑板数据，运行该Task节点会将New Actor设置为Actor Group对应的GameObject。 Task节点部分代码： 12345678910111213141516171819202122232425262728293031protected override void OnExecute() &#123; if ( cutscene.value.isActive ) &#123; EndAction(); return; &#125; cutsceneInstance = cutsceneIsPrefab ? Object.Instantiate(cutscene.value) : cutscene.value; foreach ( var replacement in replacementActors ) &#123; if ( !string.IsNullOrEmpty(replacement.groupName) &amp;&amp; replacement.newActor.value != null ) &#123; cutsceneInstance.SetGroupActorOfName(replacement.groupName, replacement.newActor.value); &#125; &#125; cutsceneInstance.defaultStopMode = stopMode; if ( waitActionFinish ) &#123; cutsceneInstance.Play(startTime.value, cutsceneInstance.length, wrapMode, () =&gt; &#123; FinalizeCutscene(); EndAction(); &#125;); &#125; else &#123; cutsceneInstance.Play(startTime.value, cutsceneInstance.length, wrapMode, () =&gt; &#123; FinalizeCutscene(); &#125;); EndAction(); &#125;&#125;protected override void OnStop() &#123; if ( waitActionFinish &amp;&amp; cutscene.value.isActive ) &#123; cutsceneInstance.Stop(stopMode); &#125;&#125; 数据传递共享黑板可以通过共享行为树黑板的方式来实现数据传递。修改Slate代码，在Actor Group中添加BlackBoard变量，在初始化Slate节点时将行为树黑板传递进Actor Group。后续任何行为树的Task节点都可以直接访问行为树的黑板 Slate添加碰撞检测节点的代码 12345678910111213141516171819public class CollisionActionClip : ActorActionClip&lt;Blackboard&gt;&#123; public string BBName; private List&lt;GameObject&gt; value; protected override void OnEnter() &#123; if (Application.isPlaying) &#123; value = Helper.Search(ActorGameObject.transform.position, 10, LayerMask.GetMask(&quot;Default&quot;)); Blackboard.SetVariableValue(BBName, value); &#125; else &#123; var mRec = new GameObject(&quot;temp&quot;); mRec.transform.localScale = Vector3.one; UDrawTool tool; tool = mRec.AddComponent&lt;UDrawTool&gt;(); tool.DrawCube(mRec.transform, Vector3.zero, 10, 10, 10, Quaternion.identity, 1f); &#125;&#125; 发送事件Slate向行为树发送event代码，支持发送各种类型的数据 1234567891011abstract public class SendGraphEvent&lt;T&gt; : ActorActionClip&lt;GraphOwner&gt;&#123; public string eventName; public T eventValue; protected override void OnEnter() &#123; if ( Application.isPlaying ) &#123; actor.SendEvent(eventName, eventValue, root); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"UE-AI","date":"2022-01-05T03:53:22.073Z","updated":"2022-03-04T09:22:50.361Z","comments":true,"path":"2022/01/05/UE-AI/","link":"","permalink":"http://example.com/2022/01/05/UE-AI/","excerpt":"","text":"UE的一个AI一般包括一下几个部分： Pawn: Pawn为AI角色； AI Controller: AI Controller用于操控Pawn（与玩家的Palyer Controller相对应）； Behavior Tree: 行为树依据不用的情况来操纵AI Controller； Black Board: 黑板用于记录一系列变量数据，给行为树的决策提供依据。 AI Perception: AI感知是actor component ，用于提供视觉，听觉，触觉等等感知，一般添加到AI Controller中 UE4行为树由事件驱动，可以通过条件装饰器观察数值，并且在可以中止其他节点。 AI 感知默认的AI Perception Component提供了视觉、听觉的配置，可视觉配置的属性如下，可以配置AI 可视半径，可视角度等一系列属性。 AI感知玩家并且设置黑板相关变量的简单例子： 如果需要定义特定的AI感知，可以继承UAISense类来实现特定感知。 服务节点服务节点是UE行为树的一种特殊功能，继承BTService_BlueprintBase，用于增加到Task节点或者复合节点，只要子节点在运行，服务节点就会以固定的频率tick，可以实现类似传统树的并行复合节点的功能，服务节点通过override Event Tick AI函数来实现特定的服务逻辑 场景查询系统（EQS）场景查询系统（EQS） 是UE4 AI系统的一个功能，可将其用于从环境中收集数据。在EQS中，可以通过不同种类的测试向收集的数据提问，这些测试会根据提出问题的类型来生成最适合的项目。 一次场景查询主要包括以下部分： 生成器（Generator），用于生成位置或actor，生成的东西被称为项目（item） 测试（Test），为所有的item打分（过滤），最终可以得到最佳的item 情景（Context），为各种测试和生成器提供引用，例如为距离测试提供一个衡量距离的Actor 生成器： Actors of Class 生成一定范围内的actor作为item Composite：合并多个生成器的结果 Points ：生成一定范围的点作为item Test：分为过滤测试（Filter）和评分（Socre）测试两类，过滤测试会移除未通过的item，评分测试会对所有的item评分，UE4中永远先进行过滤再进行评分。 UE中自带的测试包括距离测试、寻路测试、Trace测试等等，可以通过C++代码创建自定义测试。 Context：为生成器和测试提供指定Context，一般用于提供特定的点或者特定的Actor 在生成器类型的 Details 面板中，可以将查询器指定为下列属性的情境，例如在Points:Grid生成器中，生成中心默认是查询者Actor自身，也可以指定为一个Context的actor 新建一个Context： 创建 EnvQueryContext_BlueprintBase 类的新蓝图 override Provide Single Location或Provide Single Actor函数 EQS调试 单引号(‘)按键打开AI相关调试信息，默认是小键盘数字键1 2 3 4开关对应的调试信息，如果没有小键盘需要的project setting的gameplay debugger中修改按键 打开EQS调试，地面会标记当前EQS的查询结果，根据Environment Query规则给可选点进行打分，最终得到各个点的分值。 EQSTestPawn：可用于在编辑器中调试EQS查询结果，图中显示了特定点在周围的得分，该规则是过滤看不到右下角玩家的点，距离当前位置越近得分越高，该规则可以筛选出可以看到指定玩家最近的点。 用法： 创建EQSTestingPawn类型的蓝图 设置EQSTestingPawn的Query Template为指定的查询规则 AI 寻路导航区域类型设置Nav Modifier Volume可以在地图中为Cube指定区域的类型，默认的类型如下： Nav_null意味着不可走， Nav_Obstacle意味将指定相较于默认值 NavArea_Default更高的成本，寻路会尽可能避开该区域，除非代理找不到成本更低的路径。 可以通过继承Nav Area来实现自定的区域类型，修改默认成本（Default Cost） 乘数和 固定区域进入成本（Fixed Area Entering Cost）来实现自定义区域属性。 寻路查询筛选器（Navigation Query Filter）创建BP继承Navigation Query Filter，可以自定义所有导航区域的Cost，实现自定义导航路径的目的。 使用寻路查询筛选器的方式： 在Ai Controller 的Class Default设置默认的Filter 获取Controller，调用Move To函数 Navmesh生成的三种方式： Static， 寻路网格体离线生成，随关卡保存。寻路网格体在运行时加载，无法更改。 Dynamic，运行时动态生成，可以设置tick的时间 Dynamic Modifiers Only， 在运行时，只有寻路区域、寻路链接和动态对象之类的寻路修饰可以通过更改成本或阻挡区域来修改现有寻路网格体。在运行时不会生成新的寻路网格体表面。 以上生成方式可以在Project Setting或者recast中设置 Nav Modifier组件可以在运行时动态的修改NavMesh生成的网格，在Actor中添加Nav Modifier组件，可以设置Actor的区域类型， 不过运行修改的特性仅支持Dynamic Modifiers Only和Dynamic的网格生成方式。 设置（Settings） &gt; 项目设置（Project Settings），并转到 寻路系统（Navigation System） 类别。启用 仅在寻路调用程序周围生成寻路（Generate Navigation Only Around Navigation Invokers） 复选框，启用后配合动态生成方式可以仅在添加了Navigation Invoker的Actor的周围生成寻路网格，无需在编辑器中构建寻路网格，而是在运行时在代理周围生成寻路网格。 Nav Link Proxy功能是在两个点之间创建Navmesh可以识别的连接，可以用于AI通过障碍物等特定地形的导航。 Link类型： SimpleLink，可以识别到连接，但是Agent不一定能够通过，例如无法实现从下往上跳跃的过程 SmartLink，通过Event Receive SmartLink Reached来实现自定义AI速度、Play Montage等功能 SmartLink实现跳跃的例子： Link可以指定通过方向 可以结合NavArea 、NavQueryFilter，标记实现不同Nav Link的Enable Nav Area，只允许特定的Nav Area拥有该连接信息，然后通过NavQueryFilter指定包括或者排除特定Nav Area，在路径选择过程中指定NavFilter，可以实现不同AI有不同的导航地图，不同的跳跃能力 https://www.youtube.com/watch?v=5pMRqcRjC1k https://www.youtube.com/watch?v=ECys4U2fOKs&amp;list=PL4G2bSPE_8ukuajpXPlAE47Yez7EAyKMu&amp;index=12","categories":[],"tags":[]},{"title":"追踪子弹的实现","slug":"追踪子弹的实现","date":"2021-10-31T04:34:44.000Z","updated":"2021-10-31T04:47:38.082Z","comments":true,"path":"2021/10/31/追踪子弹的实现/","link":"","permalink":"http://example.com/2021/10/31/%E8%BF%BD%E8%B8%AA%E5%AD%90%E5%BC%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"要实现一个BOSS可以发射追踪子弹，子弹可以自定义初始方向，需要在子弹运行过程中依据被追踪者的Position动态修改子弹的偏转方向。 实现思路： 计算当前距离的方向和子弹的方向的角度，依据转向速度动态修改子弹的rotation 关键参数： float RotSpeed; &#x2F;&#x2F; 转向速度 GameObject mEntity; &#x2F;&#x2F; 追踪Entity的当前Gameobject GameObject mTarget; &#x2F;&#x2F;被追踪者 实现代码： 12345678910111213Vector3 dir = (mTarget.transform.position + offset -mEntity.transform.position).normalized;float a = Vector3.Angle(mEntity.transform.forward, dir) / mRotSpeed;// rotate directionif (a &gt; 0.01f || a &lt; 0.01f)&#123; mEntity.transform.forward = Vector3.Slerp(mEntity.transform.forward, dir, fTick / a).normalized;&#125;float dv = mAcc * fTick;Displace = (mSpeed + 0.5f * dv) * fTick * mEntity.transform.forward;mSpeed += dv;","categories":[],"tags":[{"name":"Game Play","slug":"Game-Play","permalink":"http://example.com/tags/Game-Play/"}]},{"title":"在Unity上实现按钮点击（短按）和长按操作","slug":"在Unity上实现按钮点击（短按）和长按操作","date":"2021-08-29T02:15:52.000Z","updated":"2021-08-29T02:19:15.986Z","comments":true,"path":"2021/08/29/在Unity上实现按钮点击（短按）和长按操作/","link":"","permalink":"http://example.com/2021/08/29/%E5%9C%A8Unity%E4%B8%8A%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%92%AE%E7%82%B9%E5%87%BB%EF%BC%88%E7%9F%AD%E6%8C%89%EF%BC%89%E5%92%8C%E9%95%BF%E6%8C%89%E6%93%8D%E4%BD%9C/","excerpt":"","text":"在项目中需要完成长按技能显示技能详情的功能，由于Unity的Button只有Click时间，所以button不足以实现这个的功能。 实现方式：使用图片作为技能显示，通过继承MonoBehaviour,IPointerDownHandler,IPointerUpHandler,IPointerExitHandler接口来获取鼠标在Image上的操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/// &lt;summary&gt;/// 脚本位置：UGUI按钮组件身上/// 脚本功能：实现角色技能的短按（技能释放）/长按(显示技能详情)状态的判断/// &lt;/summary&gt; // 继承：按下，抬起和离开的三个接口public class OnSkillPressed :MonoBehaviour,IPointerDownHandler,IPointerUpHandler,IPointerExitHandler&#123; public int skillIndex; // 延迟时间 private float delay = 0.5f; // 技能图标是否是按下状态 private bool isDown = false; // 技能图标是否已经触发长按操作 private bool isLongPress = false; // 按钮最后一次是被按住状态时候的时间 private float lastIsDownTime; private GameMsg gameMsg = GameMsg.Instance; void Update () &#123; // 如果按钮是被按下状态 if (isDown &amp;&amp; (!isLongPress)) &#123; // 当前时间 - 按钮最后一次被按下的时间 &gt; 延迟时间0.2秒 if (Time.time - lastIsDownTime &gt; delay) &#123; // 触发长按方法 isLongPress = true; Debug.Log(&quot;长按技能： &quot; + skillIndex.ToString()); gameMsg.SendMessage(GameMsgType.LongPressSkill, skillIndex); // 记录按钮最后一次被按下的时间 // lastIsDownTime = Time.time; &#125; &#125; &#125; // 当按钮被按下后系统自动调用此方法 public void OnPointerDown (PointerEventData eventData) &#123; lastIsDownTime = Time.time; isDown = true; &#125; // 当按钮抬起的时候自动调用此方法 public void OnPointerUp (PointerEventData eventData) &#123; if (Time.time - lastIsDownTime &lt; delay) &#123; // Debug.Log(&quot;短按技能（显示技能范围）： &quot; + skillIndex.ToString()); gameMsg.SendMessage(GameMsgType.TapSkill, skillIndex); &#125; else &#123; gameMsg.SendMessage(GameMsgType.LongPressSkillCancel); &#125; isDown = false; isLongPress = false; &#125; // 当鼠标从按钮上离开的时候自动调用此方法 public void OnPointerExit (PointerEventData eventData) &#123; if (isLongPress) gameMsg.SendMessage(GameMsgType.LongPressSkillCancel); isDown = false; isLongPress = false; &#125;&#125;","categories":[],"tags":[]},{"title":"Bug","slug":"Bug","date":"2021-08-28T15:50:30.000Z","updated":"2021-08-28T15:51:14.739Z","comments":true,"path":"2021/08/28/Bug/","link":"","permalink":"http://example.com/2021/08/28/Bug/","excerpt":"","text":"这篇博客记录一下自己在unity开发过程种遇到的各种bug。 (1)我们unity项目中的游戏流程管理类使用了MonoSingleton的单例模式，会随场景一同初始化和销毁，这个类会在初始化的时候注册消息，在exit时候取消监听。然而项目采用的Gamemsg消息系统是普通单例模式，全局唯一，这导致场景退出时消息没有取消监听，Action也不会被销毁，当第二次加载场景时Gamemsg会触发上一个游戏流程管理类的Action导致报错。 目前的处理方式是，在场景销毁时清空所有消息的监听。另一个方式是Gamemsg也采用MonoSingleton的单例模式，但是我们项目在其余场景也会使用消息系统所以没有采取这种方式。","categories":[],"tags":[]},{"title":"简单的闪烁脚本","slug":"简单的闪烁脚本","date":"2021-08-23T13:39:30.000Z","updated":"2021-08-23T13:47:25.040Z","comments":true,"path":"2021/08/23/简单的闪烁脚本/","link":"","permalink":"http://example.com/2021/08/23/%E7%AE%80%E5%8D%95%E7%9A%84%E9%97%AA%E7%83%81%E8%84%9A%E6%9C%AC/","excerpt":"","text":"场景：每次释放技能需要在确认前使得要消耗的行动点闪烁 实现思路：增加CanvasGroup，通过控制alpha值来实现闪烁 https://blog.csdn.net/qq_27489007/article/details/83745791 脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667using UnityEngine;using System.Collections;using UnityEngine.UI;public class ShanShuoAnim : MonoBehaviour &#123; private float alpha = 0.2f; private float alphaSpeed = 8f; private bool isShow = true;//用来控制闪烁的内容 private CanvasGroup cg; private bool isClick = false;//用来控制 彻底不需要走动画了 private Image shanImg; public Sprite shan_sprite; //外部传进来的 void Start() &#123; cg = this.transform.GetComponent&lt;CanvasGroup&gt;(); shanImg = this.transform.GetComponent&lt;Image&gt;(); &#125; void Update() &#123; if (isClick) &#123; if (isShow) &#123; if (alpha != cg.alpha) &#123; cg.alpha = Mathf.Lerp(cg.alpha, alpha, alphaSpeed * Time.deltaTime); //这个方法表示的是一种简便过程 传入初始和想达到的 if (Mathf.Abs(alpha - cg.alpha) &lt;= 0.01) &#123; //Debug.Log(&quot;更新2===&quot; + alpha + &quot;===&quot; + cg.alpha); cg.alpha = alpha; isShow = false; &#125; &#125; &#125; else &#123; if (1 != cg.alpha) &#123; cg.alpha = Mathf.Lerp(cg.alpha, 1, alphaSpeed * Time.deltaTime); //这个方法表示的是一种简便过程 传入初始和想达到的 if (Mathf.Abs(1 - cg.alpha) &lt;= 0.01) &#123; //Debug.Log(&quot;更新3===&quot; + alpha + &quot;===&quot; + cg.alpha); cg.alpha = 1; isShow = true; &#125; &#125; &#125; &#125; &#125; public void ShowAnim() &#123; //alpha = 1; isClick = true; shanImg.sprite = shan_sprite; //cg.blocksRaycasts = true;//可以和该UI对象交互 &#125; public void HideAnim() &#123; isClick = false; //alpha = 0; //cg.blocksRaycasts = false;//不可以和该UI对象交互 &#125;&#125;","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Game Play","slug":"Game-Play","permalink":"http://example.com/tags/Game-Play/"}]}