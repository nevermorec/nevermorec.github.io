{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://nevermorec.gitee.io","root":"/"},"pages":[],"posts":[{"title":"静态Enity AOI管理","slug":"静态Enity AOI","date":"2023-01-15T03:50:30.000Z","updated":"2023-07-29T06:47:40.764Z","comments":true,"path":"2023/01/15/静态Enity AOI/","link":"","permalink":"http://nevermorec.gitee.io/2023/01/15/%E9%9D%99%E6%80%81Enity%20AOI/","excerpt":"","text":"这里说的静态Entity指的是位置确定的物体，可以在玩家靠近时加载生成，玩家离开时销毁Entity。为了把性能消耗降到最低，同时不影响玩家的游戏体验，就只会向玩家生成并感兴趣的区域的静态Entity，也就是AOI进行广播。下面介绍的网格法AOI，以一个100*100的地图为例，每10米划分一个网格，就能将整个地图映射到x(0, 1,…,10)和y(0, 1,…,10)的坐标上，游戏运行时仅需要向玩家生成这个坐标附近的网格Entity（AOI范围内）即可，对于玩家AOI范围外的Entity进行销毁。示意图如下，黄色部分是AOI范围内 AOI EntityAOI Entity 是所以静态Enity类的抽象类 123456public abstract class AOIEntity&#123; public string key; public bool visiable = false;&#125; StaticAOIManagerStaticAOIManager是静态Entity的单例类，下面介绍其中的关键方法，和属性。 属性123456789101112131415private Dictionary&lt;string, Action&lt;AOIEntity&gt;&gt; _onSpawnDict = new Dictionary&lt;string,Action&lt;AOIEntity&gt;&gt;();private Dictionary&lt;string, Action&lt;AOIEntity&gt;&gt; _onDestroyDict = new Dictionary&lt;string,Action&lt;AOIEntity&gt;&gt;();private Dictionary&lt;int, List&lt;AOIEntity&gt;&gt; _indexToEnityDict = new Dictionary&lt;int,List&lt;AOIEntity&gt;&gt;();private List&lt;AOIEntity&gt; _curVisiableEntity = new List&lt;AOIEntity&gt;();public float gridSize = 10;public int AOIRange = 3;public GameObject player;private int _lastIndex = -1; StaticAOIManager使用Key（string）作为不同类型Entity的标识 _onSpawnDict和_onDestroyDict 是生成和销毁的回调函数 _indexToEnityDict 是坐标唯一index对应的所有entity的Dict _curVisiableEntity 是当前可见的entity，即在AOI范围内的entity gridSize 网格切分大小 AOIRange AOI范围 _lastIndex 记录上一帧的玩家坐标Index，如果不变不需要进行AOI更新 世界坐标映射到网格坐标12345private Vector3Int GetGridPos(Vector3 position)&#123; return new Vector3Int(Convert.ToInt32(position.x / gridSize), Convert.ToInt32(position.y / gridSize), Convert.ToInt32(position.z / gridSize));&#125; 网格坐标转成唯一ID可以直接用网格坐标作为唯一ID，此处为了性能将网格坐标映射到一个int 1234567891011private int GetGridIndexByGridPos(Vector3Int gridPos)&#123; int res = 0; if (gridPos.x &lt; 0) res = res | (1 &lt;&lt; 11); res |= Mathf.Abs(gridPos.x); if (gridPos.y &lt; 0) res = res | (1 &lt;&lt; 21); res |= Mathf.Abs(gridPos.y); if (gridPos.z &lt; 0) res = res | (1 &lt;&lt; 31); res |= Mathf.Abs(gridPos.z); return res;&#125; 注册生成和销毁回调函数123456789// 注册生成函数public void Regiseter(string key, Action&lt;AOIEntity&gt; onSpawnCallback, Action&lt;AOIEntity&gt; onDestroyCallback)&#123; if (onSpawnCallback!= null) _onSpawnDict[key] = onSpawnCallback; if (onDestroyCallback != null) _onDestroyDict[key] = onDestroyCallback;&#125; 增加一个Entity的生成点123456789101112// 增加生成点public void AddSpawnPoint(string key, Vector3 pos, AOIEntity entity)&#123; var index = GetGridIndexByGridPos(GetGridPos(pos)); if (!_indexToEnityDict.ContainsKey(index)) &#123; _indexToEnityDict.Add(index, new List&lt;AOIEntity&gt;()); &#125; var entityList = _indexToEnityDict[index]; entityList.Add(entity);&#125; pos表示该entity的生成位置，如果这个pos在AOI范围内会出发生成entity AOI更新函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private void Update()&#123; if (_indexToEnityDict.Count == 0 || player == null) return; var gridPos = GetGridPos(player.transform.position); var playerIndex = GetGridIndexByGridPos(gridPos); if (playerIndex == _lastIndex) return; _lastIndex = playerIndex; List&lt;AOIEntity&gt; enterEntityList = new List&lt;AOIEntity&gt;(); List&lt;AOIEntity&gt; leaveEntityList = new List&lt;AOIEntity&gt;(); List&lt;AOIEntity&gt; newVisiableEntityList = new List&lt;AOIEntity&gt;(); for (int i = -AOIRange; i &lt; AOIRange; i++) &#123; for (int j = -AOIRange; j &lt; AOIRange; j++) &#123; for (int k = -AOIRange; k &lt; AOIRange; k++) &#123; var index = GetGridIndexByGridPos(new Vector3Int(gridPos.x + i, gridPos.y + j, gridPos.z + k)); _indexToEnityDict.TryGetValue(index, out var entityList); if (entityList != null) &#123; newVisiableEntityList.AddRange(entityList); foreach (var entity in entityList) &#123; if (!_curVisiableEntity.Contains(entity)) &#123; enterEntityList.Add(entity); &#125; &#125; &#125; &#125; &#125; &#125; foreach (var entity in _curVisiableEntity) &#123; if (!newVisiableEntityList.Contains(entity)) &#123; leaveEntityList.Add(entity); &#125; &#125; _curVisiableEntity = newVisiableEntityList; foreach (var entity in enterEntityList) &#123; _onSpawnDict.TryGetValue(entity.key, out var onSpawnCallback); if (onSpawnCallback != null) &#123; onSpawnCallback.Invoke(entity); &#125; &#125; foreach (var entity in leaveEntityList) &#123; _onDestroyDict.TryGetValue(entity.key, out var onDestroyCallback); if (onDestroyCallback != null) &#123; onDestroyCallback.Invoke(entity); &#125; &#125;&#125; 运行逻辑大体是，如果玩家位置对应的网格坐标发生了变化，需要进行AOI的Entity更新AOI的Entity更新步骤如下： 获取新AOI范围内的所有entity 计算新进入的entity，调用onSpawn回调 计算离开的entity，调用onDestroy回调 更新当前的AOI范围内的entity数组 使用方法1234567891011121314151617181920212223242526272829303132333435363738394041public class CubeEntity : AOIEntity&#123; public GameObject cube; public Vector3 position;&#125;public class CubeSpawn: MonoBehaviour&#123; public GameObject prefab; private void Awake() &#123; StaticAOIManager.Instance.Regiseter(&quot;cube&quot;, OnSpawnCallback, OnDestroyCallback); CubeEntity cubeEntity1 = new CubeEntity(); cubeEntity1.key = &quot;cube&quot;; cubeEntity1.position = new Vector3(0, 0, 0); CubeEntity cubeEntity2 = new CubeEntity(); cubeEntity2.key = &quot;cube&quot;; cubeEntity2.position = new Vector3(40, 0, 0); StaticAOIManager.Instance.AddSpawnPoint(&quot;cube&quot;, cubeEntity1.position, cubeEntity1); StaticAOIManager.Instance.AddSpawnPoint(&quot;cube&quot;, cubeEntity2.position, cubeEntity2); &#125; private void OnSpawnCallback(AOIEntity obj) &#123; var cubeEntity = obj as CubeEntity; cubeEntity.cube = Instantiate(prefab); cubeEntity.cube.SetActive(true); cubeEntity.cube.transform.position = cubeEntity.position; Debug.Log(&quot;spawn cube&quot;); &#125; private void OnDestroyCallback(AOIEntity obj) &#123; var cubeEntity = obj as CubeEntity; Destroy(cubeEntity.cube); &#125; &#125; 后续优化空间 这种AOI范围是比较简单粗暴的，如果玩家在网格边界反复横条，会导致entity频繁生成和销毁，对此可以（1）离开后设置entity延迟销毁时间，如果在延迟时间内entity重新进入AOI，则该entity不需要销毁（2）设置一个比AOI范围更大的离开范围，只有entity在离开范围外才触发entity销毁","categories":[],"tags":[{"name":"AOI","slug":"AOI","permalink":"http://nevermorec.gitee.io/tags/AOI/"}]},{"title":"Unity相机拍照和水印","slug":"Unity相机拍照和水印","date":"2022-10-20T13:39:30.000Z","updated":"2023-07-29T06:50:04.332Z","comments":true,"path":"2022/10/20/Unity相机拍照和水印/","link":"","permalink":"http://nevermorec.gitee.io/2022/10/20/Unity%E7%9B%B8%E6%9C%BA%E6%8B%8D%E7%85%A7%E5%92%8C%E6%B0%B4%E5%8D%B0/","excerpt":"","text":"Unity相机拍摄实现思路：利用render texture将相机的渲染结果放在对应的texture上，texture2D.ReadPixels()和texture2D.Apply()可以将读取到camera到渲染结果 1234567891011121314151617181920212223242526272829303132-- 相机对拍摄区域拍照function UIPhoto:TakePhoto() rt = URenderTexture.GetTemporary( UScreen.width, UScreen.height, 0, URenderTextureFormat.ARGB32, URenderTextureReadWrite.sRGB) local previous = URenderTexture.active mainCamera = CameraSystem.GetMainCamera() local cameraData = CS.UnityEngine.Rendering.Universal.CameraExtensions.GetUniversalAdditionalCameraData(mainCamera); cameraData.renderType = CS.UnityEngine.Rendering.Universal.CameraRenderType.Base; mainCamera.targetTexture = rt mainCamera:Render() URenderTexture.active = rt screenShot = UTexture2D(UScreen.width, UScreen.height, CS.UnityEngine.TextureFormat.RGBA32, false) -- 读取屏幕像素信息并存储为纹理数据 screenShot:ReadPixels(CS.UnityEngine.Rect(0, 0, UScreen.width, UScreen.height), 0, 0) screenShot:Apply() cameraData.renderType = CS.UnityEngine.Rendering.Universal.CameraRenderType.Overlay; mainCamera.targetTexture = nil URenderTexture.active = previous URenderTexture:ReleaseTemporary(rt) return screenShotend Notes: 如果在没有渲染结果时调用ReadPixels()会报错：ReadPixels was called to read pixels from system frame buffer, while not inside drawing frame. UnityEngine.Texture2D:ReadPixels 有以下三种解决方式 在调用ReadPixels()前手动调用相机渲染，即调用Camera.Render() 在C#的private void OnPostRender()中调用ReadPixels() 在调用ReadPixels()前使用 yield return new WaitForEndOfFrame() 图片水印实现思路一： （1）得到水印texture （2）计算水印的相对位置 （3）利用texture2D.GetPixel(i, j) 和texture2D.SetPixels()把水印图片附加到原图上 12345678910111213141516171819202122232425262728293031-- 图片加游戏 Logo-- offset表示logo图片在原图上的相对位置，范围是0-1local function AddGameLogo(orignalTexture, offsetX, offsetY) local ResourceManager = require(&quot;Game/ResourceManager&quot;) local width = orignalTexture.width local height = orignalTexture.height local CoroutineManager = require(&#x27;Game/CoroutineManager&#x27;) CoroutineManager.Create( function() local newTexture = UTexture2D(width, height, CS.UnityEngine.TextureFormat.RGB24, false) local logoTexture = ResourceManager.Load(&#x27;logo&#x27;, typeof(CS.UnityEngine.Texture)) local offsetWidth = math.floor((width - logoTexture.width) * offsetX) local offsetHeight = math.floor((height - logoTexture.height) * offsetY) local colors = orignalTexture:GetPixels() for i = 1, logoTexture.width do for j = 1, logoTexture.height do -- body local newColor = logoTexture:GetPixel(i, j) if newColor.a ~= 0 then colors[width * (j + offsetHeight -1) + offsetWidth + i - 1] = newColor end end end newTexture:SetPixels(0, 0, width, height, colors) newTexture:Apply(false) end )end 实现思路二： 上述实现思路中SetPixels在CPU上运行，如果对大量的像素点使用SetPixels发放，会造成卡顿，因此需要一种在GPU处理图片运行的快速方法。 写一个依据透明度混合两个Texture的shader 使用Blit接口调用上述Shdaer混合Texture 文字水印如果是静态的文字可直接制作文字的图片，然后用上面的加图片水印的方式增加文字水印。 如果是动态的文字，主要的实现思路如下： 在UI中创建需要显示的特定Text，同时指定一个特定的Layer供相机渲染 创建render texture，指定相机的渲染layer，注意相机的render type必须为base，即 如果在相机在overlay模式无法输出渲染结果到render texture 得到文字水印的render texture后通过图片水印的方式增加文字水印 123456789101112131415161718192021mainCamera = GetGame().windowManager.cameralocal layerMask = 1 &lt;&lt; ULayerMask.NameToLayer(&quot;Watermark&quot;)local cacheLayerMesh = mainCamera.cullingMasklocal cameraData = CS.UnityEngine.Rendering.Universal.CameraExtensions.GetUniversalAdditionalCameraData(mainCamera);cameraData.renderType = CS.UnityEngine.Rendering.Universal.CameraRenderType.Base;mainCamera.cullingMask = layerMaskmainCamera.targetTexture = rtmainCamera:Render()URenderTexture.active = rtscreenShot = UTexture2D(UScreen.width, UScreen.height, CS.UnityEngine.TextureFormat.RGBA32, false)-- 读取屏幕像素信息并存储为纹理数据screenShot:ReadPixels(CS.UnityEngine.Rect(0, 0, UScreen.width, UScreen.height), 0, 0)screenShot:Apply()mainCamera.cullingMask = cacheLayerMeshmainCamera.targetTexture = nilURenderTexture.active = previousURenderTexture:ReleaseTemporary(rt)","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://nevermorec.gitee.io/tags/Unity/"}]},{"title":"Unity DOTS技术","slug":"Unity DOTS技术","date":"2022-08-20T13:39:30.000Z","updated":"2023-07-29T06:09:20.458Z","comments":true,"path":"2022/08/20/Unity DOTS技术/","link":"","permalink":"http://nevermorec.gitee.io/2022/08/20/Unity%20DOTS%E6%8A%80%E6%9C%AF/","excerpt":"","text":"DOTS Job System Burst编译器，native code ECS JobSystemNativeContainer - Unity 手册 (unity3d.com) Job System是Unity的多线程高性能的Worker框架，是Unity的底层技术之一。 传统多线程的可能问题： 死锁 资源竞争 Job System能够更安全的写多线程代码 原理 创建worker线程（非必要，主线程也能是worker线程） 将数据复制到worker worker线程完成计算 结果同步 原始数据自动锁定，由编译器保证其无法被占用，如果访问相同变量，会报错。 数据复制、数据安全Job System会检测所有的竞争条件，确保同一时间所有的job不存在竞争条件。 C# 作业系统通过向每个作业发送它需要操作的数据的副本来解决这个问题，而不是对控制线程中的数据的引用。 此副本隔离了数据，从而消除了竞争条件。 Job System的数据存放在非托管内存中，Job System只能访问blittable类型的数据，在托管代码和native code之间这些数据无需转换。作业调度时，使用memcpy将数据复制到非托管内存中。 在作业中分配托管内存非常慢，而且作业无法使用 Unity Burst 编译器来提高性能。Burst 是一种新的基于 LLVM 的后端编译器技术，可以简化您的工作。此编译器获取 C# 作业并生成高度优化的机器代码，从而利用目标平台的特定功能。 安全系统复制数据的过程的缺点是会将作业的结果隔离到每个副本中。为了克服此限制，需要将结果存储在一种名为 NativeContainer 的共享内存中。 作业依赖如果一个job依赖另一个job，需要通过代码建立他们的依赖 12JobHandle firstJobHandle = firstJob.Schedule();secondJob.Schedule(firstJobHandle); 如果一个作业具有许多依赖项，则可以使用 JobHandle.CombineDependencies 方法合并这些依赖项。CombineDependencies 可以将依赖项传递给 Schedule 方法 12345NativeArray&lt;JobHandle&gt; handles = new NativeArray&lt;JobHandle&gt;(numJobs, Allocator.TempJob);// 使用来自多个调度作业的 `JobHandles` 填充 `handles`...JobHandle jh = JobHandle.CombineDependencies(handles); 例子：Sum12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public struct ParallelSumJob : IJobFor&#123; [ReadOnly] public NativeArray&lt;float&gt; a; [ReadOnly] public NativeArray&lt;float&gt; b; public NativeArray&lt;float&gt; result; public void Execute(int i) &#123; result[i] = a[i] + b[i]; &#125;&#125;public class JobSample : MonoBehaviour&#123; public static int len = 100000; NativeArray&lt;float&gt; a; NativeArray&lt;float&gt; b; NativeArray&lt;float&gt; result; private void Job() &#123; DateTime beginTime = DateTime.Now; a = new NativeArray&lt;float&gt;(len, Allocator.TempJob); b = new NativeArray&lt;float&gt;(len, Allocator.TempJob); result = new NativeArray&lt;float&gt;(len, Allocator.TempJob); for (int i = 0; i &lt; len; i++) &#123; a[i] = 1; b[i] = 2; &#125; ParallelSumJob jobData = new ParallelSumJob(); jobData.a = a; jobData.b = b; jobData.result = result; var handle = jobData.ScheduleParallel(len, 32, new JobHandle()); handle.Complete(); Debug.Log(jobData.result[0]); // Native arrays must be disposed manually. a.Dispose(); b.Dispose(); result.Dispose(); DateTime endTime = DateTime.Now; //获取结束时间 TimeSpan oTime = endTime.Subtract(beginTime); Debug.Log($&quot;程序的运行时间：&#123;oTime.TotalMilliseconds&#125; 毫秒&quot;); &#125;&#125; 例子：JobSystem 实现鱼群 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public class FishGenerator : MonoBehaviour&#123; [BurstCompile] private struct FishPositionUpdateJob: IJobParallelForTransform &#123; public NativeArray&lt;float3&gt; objectVelocities; public float swimSpeed; public float deltaTime; public float turnSpeed; public int swimChangeFrequency; public float3 center; public float3 bounds; [NativeDisableContainerSafetyRestriction] public NativeArray&lt;Unity.Mathematics.Random&gt; randomArray; [NativeSetThreadIndex] private int _threadId; public void Execute(int index, TransformAccess transform) &#123; Unity.Mathematics.Random random = randomArray[_threadId]; transform.position += transform.localToWorldMatrix.MultiplyVector(new Vector3(0, 0, 1)) * swimSpeed * deltaTime * random.NextFloat(0.3f, 1.0f); var curVelocity = objectVelocities[index]; if (!curVelocity.Equals(float3.zero)) &#123; transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.LookRotation(curVelocity), turnSpeed * deltaTime); &#125; // prevent a fish-out-of-bound var curPosition = transform.position; bool randomise = true; if (curPosition.x &gt; center.x + bounds.x || curPosition.x &lt; center.x - bounds.x || curPosition.z &gt; center.z + bounds.z || curPosition.z &lt; center.z - bounds.z) &#123; Vector3 internalPosition = new Vector3(center.x + random.NextFloat(-bounds.x, bounds.x)/1.3f, 0, center.z + random.NextFloat(-bounds.z, bounds.z)/1.3f); curVelocity = (internalPosition- curPosition).normalized; objectVelocities[index] = curVelocity; transform.rotation = Quaternion.Lerp(transform.rotation, Quaternion.LookRotation(curVelocity), turnSpeed * deltaTime * 2); randomise = false; &#125; if (randomise) &#123; if (random.NextInt(0, swimChangeFrequency) &lt;= 2) &#123; objectVelocities[index] = new Vector3(random.NextFloat(-1f, 1f), 0, random.NextFloat(-1f, 1f)); &#125; &#125; randomArray[_threadId] = random; &#125; &#125; private FishPositionUpdateJob _fishPositionUpdateJob; private NativeArray&lt;float3&gt; _objectVelocities; private NativeArray&lt;Unity.Mathematics.Random&gt; _randoms; private NativeArray&lt;float3&gt; _velocities; private TransformAccessArray _transformAccessArray; public GameObject FishTemplate; public int fishCount; public BoxCollider spawnBounds; public float spawnHeight; public int swimChangeFrequency; // Start is called before the first frame update void Start() &#123; _velocities = new NativeArray&lt;float3&gt;(fishCount, Allocator.Persistent); _transformAccessArray = new TransformAccessArray(fishCount); _objectVelocities = new NativeArray&lt;float3&gt;(fishCount, Allocator.Persistent); for (int i = 0; i &lt; fishCount; i++) &#123; float distanceX = UnityEngine.Random.Range(-spawnBounds.bounds.extents.x, spawnBounds.bounds.extents.x); float distanceZ = UnityEngine.Random.Range(-spawnBounds.bounds.extents.z, spawnBounds.bounds.extents.z); Vector3 spawnPoint = spawnBounds.bounds.center + Vector3.up * spawnHeight + new Vector3(distanceX, 0, distanceZ); // generare fish obj var go = GameObject.Instantiate(FishTemplate, spawnPoint, Quaternion.identity); _transformAccessArray.Add(go.transform); // _objectVelocities[i] = new float3(1, 1, 1); &#125; // 生成线程数量的随机种子 _randoms = new NativeArray&lt;Unity.Mathematics.Random&gt;(JobsUtility.MaxJobThreadCount, Allocator.TempJob); for (int i = 0; i &lt; _randoms.Length; i++) &#123; _randoms[i] = Unity.Mathematics.Random.CreateFromIndex((uint) i); &#125; _fishPositionUpdateJob = new FishPositionUpdateJob() &#123; randomArray = _randoms, swimSpeed = 0.2f, objectVelocities = _objectVelocities, turnSpeed = 4.6f, swimChangeFrequency = swimChangeFrequency, center = spawnBounds.bounds.center, bounds = spawnBounds.bounds.extents, &#125;; &#125; // Update is called once per frame void Update() &#123; _fishPositionUpdateJob.deltaTime = Time.deltaTime; var jobHandle = _fishPositionUpdateJob.Schedule(_transformAccessArray, default); jobHandle.Complete(); &#125; private void OnDestroy() &#123; _velocities.Dispose(); _transformAccessArray.Dispose(); _randoms.Dispose(); _objectVelocities.Dispose(); &#125;&#125; 细节（1）unity中 GetComponment() 只比 GetComponment(typeof(T)) 高效一点点，但却比 GetComponment(string) 高效接近一百倍。所以，应该确保不要使用 GetComponment(string) 方法。除了一些罕见的情况，比如需要使用它来解析用户输入的字符串，从而获取一个组件。这种情况一般只会发生在自定义的调试控制器上，而对于产品级的应用，GetComponment(string) 是一种不必要的浪费。","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://nevermorec.gitee.io/tags/Unity/"}]},{"title":"Windows搭建Games101环境","slug":"Windows搭建Games101环境","date":"2022-04-24T03:28:40.000Z","updated":"2022-04-24T03:46:04.543Z","comments":true,"path":"2022/04/24/Windows搭建Games101环境/","link":"","permalink":"http://nevermorec.gitee.io/2022/04/24/Windows%E6%90%AD%E5%BB%BAGames101%E7%8E%AF%E5%A2%83/","excerpt":"","text":"本方法是通过windows平台vcpkg工具安装所需环境 安装vcpkg git安装vckpg（也可以通过其他方式） git命令： git clone &#x67;&#105;&#x74;&#x40;&#103;&#x69;&#116;&#x68;&#x75;&#x62;&#46;&#x63;&#111;&#x6d;:microsoft&#x2F;vcpkg.git 进入vcpkg目录执行bootstep-vcpkg.bat脚本 安装所需要的包，这一步需要在vcpkg目录下执行cm命令，或者将vcpkg目录添加到系统path变量上 命令： vcpkg.exe install opencv:x64-windows vcpkg.exe install eigen:x64-windows 这一步就是安装所需要的包，后面cmake过程出现的缺少包都可以通过这一步来安装 关联vcpkg安装好的包到Visual Studio 执行命令： vcpkg.exe integrate project Games101 作业编译 在作业的工程文件夹执行下面的命令： mkdir build cd build cmake .. (这一步如果缺少包可以通过步骤一的vcpkg进行安装) 然后就可以通过vs或者vs code打开build文件夹下的sln文件进行后续的编程了","categories":[],"tags":[{"name":"Game101","slug":"Game101","permalink":"http://nevermorec.gitee.io/tags/Game101/"}]},{"title":"Unity Slate和行为树接入","slug":"Slate和行为树接入","date":"2022-03-28T15:50:30.000Z","updated":"2023-07-29T06:08:21.913Z","comments":true,"path":"2022/03/28/Slate和行为树接入/","link":"","permalink":"http://nevermorec.gitee.io/2022/03/28/Slate%E5%92%8C%E8%A1%8C%E4%B8%BA%E6%A0%91%E6%8E%A5%E5%85%A5/","excerpt":"","text":"Unity Slate插件是一个TimeLine编辑器。支持在时间轴上编辑镜头、Animation、音频、角色IK等各种功能，支持扩展各种自定义节点类型。同时对Node Canvas行为树的支持也非常友好，直接集成了向行为树发送事件节点。 Slate使用界面： 通过添加Cutscene脚本即可编辑TimeLine，一个Slate Editor中可以同时存在多个组（Actor Group），Director为Slate自带的组，其余添加组的属性都带组名和GameObject。一个组内可同时存在多个轨道（Track），一个轨道是一个TImeLine，在TimeLine上可以编辑多个节点（Action Clip）,节点会在对应的时刻触发并执行对应函数。Action Clip为具体的行为片段。例如播放动画、播放特效、发送事件等功能 Slate支持自定义节点，只需要继承实现Action Clip，并且将节点添加到轨道上即可完成触发。 Slate的更新顺序为： Group Enter -&gt; Track Enter -&gt; Clip Enter | ··· Clip Update ··· | Clip Exit -&gt; Track Exit -&gt; Group Exit Slate接入行为树行为树接入Slate主要需要实现： 生成行为树的Task节点用于播放和暂停Slate 行为树和Slate的数据交互（可以通过黑板和事件交互） 序列化Slate数据 下面以Node Canvas行为树为例， 序列化客户端： 方案一可以直接将Cutscene脚本挂载到GameObject，通过序列化Prefab的方式序列化Slate数据。在行为树执行对应Slate Task时，播放Slate只需要初始化GameObject并且调用CutScene的Play方法即可。 方案二可以直接Cutscene的数据序列话成JSON、BSON等格式，运行时反序列化。 服务端：如果需要在服务端执行Slate的逻辑，需要在序列化Slate配置数据，并且在服务端实现Slate的运行逻辑。 生成行为树节点播放Slate由于序列化生成Slate节点无法得到运行时Actor Group的GameObject，需要我们在运行时动态设置。Cutscene中提供了方法SetGroupActorOfName(string groupName, GameObject newActor)，该方法可以通过组名查找替换当前的GameObject。我们可以将Slate需要的Gameobject放在黑板数据中，运行时将黑板GameObject设置到CutScene中即可。 Play Slate的Task节点： 左侧Cutscene为序列化的Slate Prefab，图中Group Name为Actor Group中的组名，New Actor为黑板数据，运行该Task节点会将New Actor设置为Actor Group对应的GameObject。 Task节点部分代码： 12345678910111213141516171819202122232425262728293031protected override void OnExecute() &#123; if ( cutscene.value.isActive ) &#123; EndAction(); return; &#125; cutsceneInstance = cutsceneIsPrefab ? Object.Instantiate(cutscene.value) : cutscene.value; foreach ( var replacement in replacementActors ) &#123; if ( !string.IsNullOrEmpty(replacement.groupName) &amp;&amp; replacement.newActor.value != null ) &#123; cutsceneInstance.SetGroupActorOfName(replacement.groupName, replacement.newActor.value); &#125; &#125; cutsceneInstance.defaultStopMode = stopMode; if ( waitActionFinish ) &#123; cutsceneInstance.Play(startTime.value, cutsceneInstance.length, wrapMode, () =&gt; &#123; FinalizeCutscene(); EndAction(); &#125;); &#125; else &#123; cutsceneInstance.Play(startTime.value, cutsceneInstance.length, wrapMode, () =&gt; &#123; FinalizeCutscene(); &#125;); EndAction(); &#125;&#125;protected override void OnStop() &#123; if ( waitActionFinish &amp;&amp; cutscene.value.isActive ) &#123; cutsceneInstance.Stop(stopMode); &#125;&#125; 数据传递共享黑板可以通过共享行为树黑板的方式来实现数据传递。修改Slate代码，在Actor Group中添加BlackBoard变量，在初始化Slate节点时将行为树黑板传递进Actor Group。后续任何行为树的Task节点都可以直接访问行为树的黑板 Slate添加碰撞检测节点的代码 12345678910111213141516171819public class CollisionActionClip : ActorActionClip&lt;Blackboard&gt;&#123; public string BBName; private List&lt;GameObject&gt; value; protected override void OnEnter() &#123; if (Application.isPlaying) &#123; value = Helper.Search(ActorGameObject.transform.position, 10, LayerMask.GetMask(&quot;Default&quot;)); Blackboard.SetVariableValue(BBName, value); &#125; else &#123; var mRec = new GameObject(&quot;temp&quot;); mRec.transform.localScale = Vector3.one; UDrawTool tool; tool = mRec.AddComponent&lt;UDrawTool&gt;(); tool.DrawCube(mRec.transform, Vector3.zero, 10, 10, 10, Quaternion.identity, 1f); &#125;&#125; 发送事件Slate向行为树发送event代码，支持发送各种类型的数据 1234567891011abstract public class SendGraphEvent&lt;T&gt; : ActorActionClip&lt;GraphOwner&gt;&#123; public string eventName; public T eventValue; protected override void OnEnter() &#123; if ( Application.isPlaying ) &#123; actor.SendEvent(eventName, eventValue, root); &#125; &#125;&#125;","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://nevermorec.gitee.io/tags/Unity/"}]},{"title":"UE-GAS(技能系统)","slug":"UE-GAS(技能系统)","date":"2022-03-20T13:39:30.000Z","updated":"2023-07-29T06:00:55.923Z","comments":true,"path":"2022/03/20/UE-GAS(技能系统)/","link":"","permalink":"http://nevermorec.gitee.io/2022/03/20/UE-GAS(%E6%8A%80%E8%83%BD%E7%B3%BB%E7%BB%9F)/","excerpt":"","text":"英文文档：https://github.com/tranek/GASDocumentation#concepts-ge-definition 中文文档：https://github.com/BillEliot/GASDocumentation_Chinese#45-gameplay-effects GA（GameAblity） GE（GameEffect） 技能冷却机制实现： 创建GE，持续事件设置为Has Duration，时间设置为CD，增加Tag、 技能GA的class default中的cooldown Game Effect设置为上面的GE GA中的event activateAbility中增加CommitAbility GAS执行流程： 通过角色的AbilitySystemCompont执行trytoactivateability(FGameplayAbility Ability)可以执行指定GA GA：激活GA后运行Event Activate Ability事件，CommitAbility用于提交扣蓝等功能。 如果是攻击技能开启碰撞检测。将HitResult或者HItActor放入TargetDataHandle中 c++放入过程： 1234FGameplayAbilityTargetDataHandle TargetDataHandle;FGameplayAbilityTargetData_SingleTargetHit* TargetData = new FGameplayAbilityTargetData_SingleTargetHit(HitResult);TargetDataHandle.Add(TargetData); 蓝图只能单个Actor或者HitResult放入TargetDataHandle中 对被释放对象施加GE 蓝图调用ApplyGamePlayEffectToTarget C++ 例子如下 TargetEffectSpecs是EffectSpecHandle的数组，ContainerSpec.TargetDataHandle包含要施加GE的actor 12345678910TArray&lt;FActiveGameplayEffectHandle&gt; UBaseGameplayAbility::ApplyEffectContainerSpec( FGamePlayEffectContainerSpec&amp; ContainerSpec)&#123; TArray&lt;FActiveGameplayEffectHandle&gt; AllEffects; for (auto TargetEffectSpec : ContainerSpec.TargetEffectSpecs) &#123; AllEffects.Append(K2_ApplyGameplayEffectSpecToTarget(TargetEffectSpec, ContainerSpec.TargetDataHandle)); &#125; return AllEffects;&#125; GamePlayAbility (GA)输入键位绑定简单的技能释放可以直接在蓝图中根据输入调用TryActivateAbility来激活指定技能。不过如果需要在GA中监听输入按钮的释放事件（Wait Input Release），则这种方式无法触发Wait Input Realse的On Release事件，必须在授予技能时指定FGameplayAbilitySpec中的InInputID，在GAS的按钮监听中UAbilitySystemComponent::AbilityLocalInputPressed才能触发按钮的Release事件 绑定单个技能到特定键位12345678910111213141516171819bool AMyCCharacter::AddAbilityOnInput(TSubclassOf&lt;UGameplayAbility&gt; Ability, FString InputValue, int32 InputID)&#123; if (AbilitySystemComp &amp;&amp; Ability) &#123; AbilitySystemComp-&gt;GiveAbility(FGameplayAbilitySpec(Ability, 1, InputID)); AbilitySystemComp-&gt;InitAbilityActorInfo(this, this); FInputActionBinding ABPressed(FName(InputValue), IE_Pressed); ABPressed.ActionDelegate.GetDelegateForManualSet().BindUObject(AbilitySystemComp, &amp;UBaseAbilitySystemComponent::AbilityLocalInputPressed, InputID); InputComponent-&gt;AddActionBinding(ABPressed); FInputActionBinding ABReleased(FName(InputValue), IE_Released); ABReleased.ActionDelegate.GetDelegateForManualSet().BindUObject(AbilitySystemComp, &amp;UBaseAbilitySystemComponent::AbilityLocalInputReleased, InputID); InputComponent-&gt;AddActionBinding(ABReleased); return true; &#125; return false;&#125; InputValue为项目设置Input对应的键值，InputID为自定义的int32，只要设置为不重复即可。绑定了确认和释放按钮后可以在GA中使用Wait Input Release来完成游戏逻辑。 GamePlayeEffect（GE）GE的执行流程属性修改（Attribute Modifier）在GE中可以包含多个Modifier，而每一个Modifier会设定一个数值和一种运算方式，并对应修改一个Attribute。其中包含四种运算方式：1）Add(加&#x2F;减)；2）Multiply乘；3）Divide除；4）Override覆盖。四种Modifier最终的运算结果在FAggregatorModChannel::EvaluateWithBase里定义，默认： CurrentValue &#x3D; ((InlineBaseValue + Additive) * Multiplicitive) &#x2F; Division（如果有Override则直接覆盖结果） Modifier的取值有四种类型，这部分的设置十分重要，因为会与游戏逻辑密切挂钩： Scalable Float：可指定一个表中数据，然后乘上一个因数； Attribute Based：以Attribute的值作为基值然后乘上因数（采用快照Snapshotting实现） Custom Calculation Class：自定义类，需要引入一个ModifierMagnitudeCalculation类(MMC)，参考范例中根据现有的蓝量和Tag计算最终造成多少蓝量的损失。这种方式的优点时可以被预测而且可用于每一类GE，但最终还是指定修改一种Attribute。 Set By Caller：根据释放的技能主体来设定，比如蓄力长短决定的伤害量、资产中设置的数值。需要通过GameplayEffectSpec中的TMap&lt;FGameplayTag, float&gt;索引相关的值，Tag不存在时返回0。这种类型广泛用于可复用的GE。通过调用AssignTagSetByCallerMagnitude来指定特定Tag对应的float值。 UGameplayEffectExecutionCalculation （自定义属性数值计算类）使用方法： 继承UGameplayEffectExecutionCalculation 自定义初始化方法（定义从Source和Target捕获的相关属性）， overrider Execute_Implementation函数，实现自定义的计算逻辑 初始化方法 方式一： 12345678910UPAMMC_PoisonMana::UPAMMC_PoisonMana()&#123; //ManaDef defined in header FGameplayEffectAttributeCaptureDefinition ManaDef; ManaDef.AttributeToCapture = UPAAttributeSetBase::GetManaAttribute(); ManaDef.AttributeSource = EGameplayEffectAttributeCaptureSource::Target; ManaDef.bSnapshot = false; RelevantAttributesToCapture.Add(ManaDef);&#125; 需要定义捕获数据的来源（Source还是Target），哪个属性，快照方式（bSnapshot） 快照规则如下： 方式二： 12345678910111213141516171819202122232425struct RPGDamageStatics&#123; DECLARE_ATTRIBUTE_CAPTUREDEF(AttackPower); DECLARE_ATTRIBUTE_CAPTUREDEF(DefensePower); DECLARE_ATTRIBUTE_CAPTUREDEF(Health); RPGDamageStatics() &#123; DEFINE_ATTRIBUTE_CAPTUREDEF(UAttributeSetBase, AttackPower, Source, true); DEFINE_ATTRIBUTE_CAPTUREDEF(UAttributeSetBase, DefensePower, Target, false); DEFINE_ATTRIBUTE_CAPTUREDEF(UAttributeSetBase, Health, Target, false); &#125;&#125;;static const RPGDamageStatics&amp; DamageStatics()&#123; static RPGDamageStatics DmgStatics; return DmgStatics;&#125;UAttackEffectExecutionCalculation::UAttackEffectExecutionCalculation()&#123; RelevantAttributesToCapture.Add(DamageStatics().AttackPowerDef); RelevantAttributesToCapture.Add(DamageStatics().DefensePowerDef);&#125; 12345678910111213141516171819202122void UAttackEffectExecutionCalculation::Execute_Implementation(const FGameplayEffectCustomExecutionParameters&amp; ExecutionParams, FGameplayEffectCustomExecutionOutput&amp; OutExecutionOutput) const&#123; UAbilitySystemComponent* SourceASC = ExecutionParams.GetSourceAbilitySystemComponent(); UAbilitySystemComponent* TargetASC = ExecutionParams.GetTargetAbilitySystemComponent(); FGameplayEffectSpec EffectSpec = ExecutionParams.GetOwningSpec(); FAggregatorEvaluateParameters EvaluateParameters; EvaluateParameters.SourceTags = EffectSpec.CapturedSourceTags.GetAggregatedTags(); EvaluateParameters.TargetTags = EffectSpec.CapturedTargetTags.GetAggregatedTags(); float AttackPower = 0.0f; ExecutionParams.AttemptCalculateCapturedAttributeMagnitude(DamageStatics().AttackPowerDef, EvaluateParameters, AttackPower); float DefensePower = 0.0f; ExecutionParams.AttemptCalculateCapturedAttributeMagnitude(DamageStatics().DefensePowerDef, EvaluateParameters, DefensePower); float Damage = -(AttackPower - DefensePower); OutExecutionOutput.AddOutputModifier(FGameplayModifierEvaluatedData(DamageStatics().HealthProperty, EGameplayModOp::Additive, Damage));&#125; OutExecutionOutput.AddOutputModifier()中定义最终要给Target的Modifier 冷却GE（Cooldown GamePlayEffect） Cooldown GE是Duration类型的GE，没有Modifier，但需要赋予自身ASC一个“Cooldown.xxx.xxx”的tag。可以通过以下三种方式之一实现冷却时间和Tag的配置： 直接配置在单个CooldownGameplayEffect的Modifier中（固定值），这样比较直观但灵活性差。 用SetByCaller，配置tag“Data.Cooldown”对应的数值来设定技能的冷却时间。并且需要重写UGameplayAbility::GetCooldownTags()和UGameplayAbility::ApplyCooldown() 具体用法：把CoolDown GE的持续时间设置为Set By Caller，overrider ApplyCooldown函数，将CoolDown GE的持续时间设置为自定义的值。SpecHandle.Data.Get()-&gt;SetSetByCallerMagnitude可以完成自定义值的设置 12345678910void UBaseGameplayAbility::ApplyCooldown(const FGameplayAbilitySpecHandle Handle, const FGameplayAbilityActorInfo* ActorInfo, const FGameplayAbilityActivationInfo ActivationInfo) const&#123; UGameplayEffect* CooldownGE = GetCooldownGameplayEffect(); if (CooldownGE) &#123; FGameplayEffectSpecHandle SpecHandle = MakeOutgoingGameplayEffectSpec(CooldownGE-&gt;GetClass(), GetAbilityLevel()); SpecHandle.Data.Get()-&gt;SetSetByCallerMagnitude(CooldownTag, CooldownDuration.GetValueAtLevel(GetAbilityLevel())); ApplyGameplayEffectSpecToOwner(Handle, ActorInfo, ActivationInfo, SpecHandle); &#125;&#125; Cooldown GamePlay SetSetByCallerMagnitude 在Modifier中自定义MMC，在MMC中获取Ability中设定的冷却时间。并且需要重写UGameplayAbility::GetCooldownTags()和UGameplayAbility::ApplyCooldown() AttributeAttribute是由FGameplayAttributeData结构体定义的浮点值，其可以表示从角色生命值到角色等级再到一瓶药水的剂量的任何事物，如果某项数值是属于某个Actor且游戏相关的，你就应该考虑使用Attribute。Attribute一般应该只能由GE修改，这样ASC才能预测(Predict)其改变。一般Attribute需要由AttributeSet进行保存和管理，而AttributeSet注册于ASC中并受其管理，因此Attribute的访问一般也是通过ASC完成的。 每个Attribute都有一个BaseValue和CurrentValue，需要格外注意的是BaseValue不是CurrentValue的最大值！CurrentValue用于那些有持续时间的GE造成的Attribute更改，当GE消失时CurrentValue会变回BaseValue（比如加速减速）；而BaseValue处理的是一次性、永久生效的效果，因此生命值受到伤害时，改变的是BaseValue而不是CurrentValue。更具体的，BaseValue受Instant和Periodic类GE的影响，而CurrentValue受Duration和Infinite类GE影响。(注：CurrentValue受Duration和Infinite影响的提前是没有定义为Period，如果定义了Period，则Duration的GE为视为多个Instant GE的组合，其对BaseValue的修改和GameplayCue的执行方式如同Instant类。) Attribute的监听和修改相关函数Attribute的修改最好是都通过GE来完成，这样一来可以有效地触发回调函数，而且在实现客户端预测时，也有办法把错误判断修改的数值进行回退。以下是几种常用的监听Attribute变化的方式： 数值变化生效前，会调用**UAttributeSet::PreAttributeChange(const FGameplayAttribute&amp; Attribute, float&amp; NewValue)**，需要对数值限值的话在此处完成，参考范例。建议该函数内只做限值，不处理游戏逻辑。 由GE引起的数值变化生效后，但在同步至客户端之前，会调用**UAttributeSet::PostGameplayEffectExecute(const FGameplayEffectModCallbackData &amp; Data)**，可参考范例。在Data中可以获取GE相关的各种信息，因此可以处理各种GE作用后的逻辑，比如伤害的生效。由于数值还没同步到客户端，因此进一步限值需要在此完成，比如限制Health不能小于0。 在ASC中绑定委托和回调函数，实现Attribute的监听，如下所示。此处一般处理与数值无关的一些逻辑，比如通过委托进一步触发受击动作、UI变化等逻辑。(FOnAttributeChangeData为struct类型，无法直接暴露到蓝图中（不能直接使用BlueprintImplementableEvent），可考虑自定义委托然后在PostGameplayEffectExecute中直接广播) 123AbilitySystemComponent-&gt;GetGameplayAttributeValueChangeDelegate(AttributeSetBase-&gt;GetHealthAttribute()).AddUObject(this, &amp;AGDPlayerState::HealthChanged);// 定义血量变化时的回调函数void AGDPlayerState::HealthChanged(const FOnAttributeChangeData&amp; Data) &#123;&#125; Ability Task自定义AbilityTask通常你需要创建自己的自定义AbilityTask(C++中). 样例项目带有两个自定义AbilityTask: PlayMontageAndWaitForEvent是默认PlayMontageAndWait和WaitGameplayEventAbilityTask的结合体, 其允许动画蒙太奇自AnimNotify发送GameplayEvent回到启动它的GameplayAbility, 可以使用该Task在动画蒙太奇的某个特定时刻来触发操作. WaitReceiveDamage可以监听OwnerActor接收伤害. 当英雄接收到一个伤害实例时, 被动护甲层GameplayAbility就会移除一层护甲. AbilityTask的组成: 创建新的AbilityTask实例的静态函数 当AbilityTask完成目的时分发的委托(Delegate) 进行主要工作的Activate()函数, 绑定到外部的委托等等 进行清理工作的OnDestroy()函数, 包括其绑定到外部的委托 所有绑定到外部委托的回调函数 成员变量和所有内部辅助函数 Note: AbilityTask只能声明一种类型的输出委托, 所有的输出委托都必须是该种类型, 不管它们是否使用参数. 对于未使用的委托参数会传递默认值. 在GA中实现Tick节点 继承UAbilityTask，设置bTickingTask&#x3D;true 新建一种委托，可以在蓝图中实现委托函数 利用static函数new当前的AbilityTask对象 override TickTask，广播委托 12345678910111213141516171819202122DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnTickDelegate, float, DeltaTime);UCLASS()class UETEST_API UAbilityTask_AbilityTick : public UAbilityTask&#123; GENERATED_BODY()public: UAbilityTask_AbilityTick(); UFUNCTION(BlueprintCallable, Category = &quot;Ability|Tasks&quot;, meta = (HidePin = &quot;OwningAbility&quot;, DefaultToSelf = &quot;OwningAbility&quot;, BlueprintInternalUseOnly = &quot;TRUE&quot;)) static UAbilityTask_AbilityTick* AbilityTick(UGameplayAbility* OwningAbility); UPROPERTY(BlueprintAssignable) FOnTickDelegate OnTickDelegate; protected: /** Tick function for this task, if bTickingTask == true */ virtual void TickTask(float DeltaTime) override; virtual void OnDestroy(bool AbilityIsEnding) override; &#125;; 1234567891011121314151617UAbilityTask_AbilityTick::UAbilityTask_AbilityTick()&#123; bTickingTask = true;&#125;void UAbilityTask_AbilityTick::TickTask(float DeltaTime)&#123; Super::TickTask(DeltaTime); OnTickDelegate.Broadcast(DeltaTime);&#125;UAbilityTask_AbilityTick* UAbilityTask_AbilityTick::AbilityTick(UGameplayAbility* OwningAbility)&#123; UAbilityTask_AbilityTick* MyObj = NewAbilityTask&lt;UAbilityTask_AbilityTick&gt;(OwningAbility); return MyObj;&#125; Note: 在多人游戏中使用mesh的PlayMontage不能自动同步蒙太奇，需要使用GAS自带的PlayMontageAndWait(AbilityTask)才能同步蒙太奇","categories":[],"tags":[{"name":"Game Play","slug":"Game-Play","permalink":"http://nevermorec.gitee.io/tags/Game-Play/"}]},{"title":"UE_Advanced ARPG Melee Combat System学习笔记","slug":"UE_Advanced ARPG Melee Combat System学习笔记","date":"2022-02-20T13:39:30.000Z","updated":"2023-07-29T06:56:26.907Z","comments":true,"path":"2022/02/20/UE_Advanced ARPG Melee Combat System学习笔记/","link":"","permalink":"http://nevermorec.gitee.io/2022/02/20/UE_Advanced%20ARPG%20Melee%20Combat%20System%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"CharacterStateManagerComponentFunction SetAction(设置动作，不包括动画) SetState Event Action Begin (在设置动作开始时触发，主要包括镜头等处理) Action End MontageManagerComponentFunction GetGeneralActionMontage SetState CollisionComponentEvent OnCollisionEnable （打开碰撞检测，触发CollisionTrace事件） CollisionTrace （循环检测碰撞直到EnableCollisionTrace被设置成false，循环期间根据碰撞信息触发OnHit事件，OnHit事件的具体逻辑由角色蓝图进行控制） InputBufferNS: AnimNotifyState该类配合动画Montage中的Nofities来控制特定动作时间内才允许接受玩家输入 Function Received_NotifyBegin Received_NotifyEnd 攻击动画蒙太奇的配置 InputBufferNS控制玩家输入缓存 AttackTraceNS：AnimNotifyState该类配合动画Montage中的Nofities来控制攻击过程中的碰撞体 Function Received_NotifyBegin 1234（1）根据类型执行相关逻辑（2）如果是武器，获取当前武器和武器碰撞体的相关信息，调用武器CollisionComponent中的Enable Collision事件（开启碰撞检测，清除之前的碰撞信息）（3）如果是四肢，打开四肢的碰撞体（4）如果是盾牌，打开盾牌的碰撞体 Received_NotifyEnd(关闭碰撞体) 攻击动画蒙太奇的整体流程： 初始化过程中就会将主角Actor中的碰撞体引用绑定到Collision Component上 （1）动画蒙太奇配置AttackTraceNS(AnimNotifyState)，Received_NotifyBegin调用角色实现的CombatBPI接口存储此次攻击信息（Update Attack Info），同时打开武器碰撞体检测，打开期间根据循环检测是否碰撞 （2）检测通过MultiSphereTraceForObject函数，将检测结果放入HItActors数组中 （3）处理碰撞结果，调用OnHit事件，主要是根据碰撞信息和人物攻击力等数值信息播放受击动画、特效，造成伤害等 （4）AttackTraceNS的Received_NotifyEnd关闭武器碰撞体 AI的攻击蒙太奇主要靠Attack_Trace_AI实现 碰撞检测造成伤害流程 攻击蒙太奇中开启碰撞检测，产生碰撞结果后会调用当前持有Collision Componet的Actor的On Hit事件， 武器的On Hit事件 如果被击中的Actor是Pawn，则执行Try to Apply Damge（在服务端运行，Try to Apply Damge中根据武器的自身设置和持有武器的Actor调用UE中自带的Actor伤害系统（Apply Damage函数）），然后调用持有武器Actor 的On Hit事件。 如果Actor不是Pawn则调用武器持有者的On Hit事件 主角Actor的On Hit事件会调用On Melee Hit事件： 获取动画蒙太奇中配置的Attack Info 获取被攻击者的Hit React Component Make Combat Hit Data中计算两者距离、攻击方向、调用受击者的Get Impact Decision得到当前是否格挡，Store CombitHit Data将受击信息（CombatHitData_Struct）存储到受击者的Hit Reaction Component中，后面的受击者的伤害计算、受击反馈等需要使用该数据 在被攻击者的Hit React Component的设置碰撞信息，包括碰撞骨骼，碰撞位置等 伤害计算后攻击者通过Apply Damage传递攻击的相关数据，被攻击者接收Event AnyDamage事件处理伤害 调用被攻击者Hit React Component播放受击动画、特效等 普攻连击流程： MontageComponent中的DataTable中引用了CombatMontagesDataTable，该表格存储了一套动作连招的所有蒙太奇。 执行普通攻击的入口： Attack Type类型包括Light attack、strong attack等枚举类型 设置CombatComponet中的attack type 设置CharacterStateManager中的Action(这里是Attack，CharacterStateManager会处理新旧Action切换的一些行为) 设置CharacterStateManager中的State(这里是Attacking，CharacterStateManager会处理新旧State切换的一些行为) 清除ResetAttackHandle计时器（计时器的作用是重置当前的Attack Count，这里的清除作用是允许角色继续连击，增加Attack Count） 根据Attack Type和Attack Index获取要执行的蒙太奇 Inform AI of An Attack通知相关AI角色要执行的动作，供AI后续执行自己的处理 播放动画蒙太奇 Attack Count++，如果Attack Count没有被重置下次执行Perform Attack则会索引到下一个配置好的蒙太奇动画 设置重置Attack Count的定时器（demo这里设置为蒙太奇时间*0.8） 检测蒙太奇是否播放成功，成功则执行StatsComponent中的Modify Current Stat Value扣除法力，耐力等逻辑 ARPG的连击方法： JumpSectionNS 期间内可以连击， JumpSections 存储了可以跳转的Section 期间在此触发相同普攻，会依据 JumpSections设置的 JumpSections来跳转到指定section。 基础设定 Character State： Character Action： Get General Action Montage： 得到当前要播放的蒙太奇动画 每次更新武器会替换当前的Switch weapon的蒙太奇动画 蒙太奇动画管理： 不同武器之间对应不同的蒙太奇动画，需要在切换武器时切换当前角色的蒙太奇动画 CombatMontagesDataTable数据表中存储了不同武器下的蒙太奇动画（装备武器、攻击、翻滚动作、受击反馈动画等等） 当触发EquipmentManagerComponent中的OnCombatTypeChange事件（武器该表）时，调用MonatgeManagerComponent中的UpdateMontage函数处理蒙太奇动画的更新。 多角色蒙太奇配合： 以暗杀为例，暗杀需要两个角色配合表演完整的暗杀动画。 暗杀者通过向前的碰撞检测敌人，如果有敌人检查是否满足暗杀条件，条件成功执行暗杀，并且将被暗杀者的背板值General AI State设置为Assasinated，通过被暗杀者的行为树控制表演被杀动画。 AI AI的行为树分为一下几个部分： 进入战斗（播放装备武器动画、修改General AI State） 退出战斗 巡逻 战斗 服务节点：BTS_AIDecisionMaker， 战斗子行为树的实现： 服务节点：BTS_TrackPlayerState，该服务设置当前角色的AI Action，包括Attack、Block、Dodge、Hit等，叶子节点负责执行对应的AI Action 攻击Task节点：根据BTS_AIDecisionMaker设置的攻击方式进行攻击 数据存储继承SaveGame，在类中自定义需要存储的数据 在GameInstance中新建变量CurSavedGame，变量类型是上面的类 载入数据： 保存数据到文件： Save Game to Slot会创建一个(Slot Name).sav的文件，本地保存路径为Saved&#x2F;SavedGame&#x2F;(Slot Name).sav","categories":[],"tags":[{"name":"UE,GAMEPLAY","slug":"UE-GAMEPLAY","permalink":"http://nevermorec.gitee.io/tags/UE-GAMEPLAY/"}]},{"title":"UE-AI","slug":"UE-AI","date":"2022-01-20T13:39:30.000Z","updated":"2023-07-29T06:53:38.696Z","comments":true,"path":"2022/01/20/UE-AI/","link":"","permalink":"http://nevermorec.gitee.io/2022/01/20/UE-AI/","excerpt":"","text":"UE的一个AI一般包括一下几个部分： Pawn: Pawn为AI角色； AI Controller: AI Controller用于操控Pawn（与玩家的Palyer Controller相对应）； Behavior Tree: 行为树依据不用的情况来操纵AI Controller； Black Board: 黑板用于记录一系列变量数据，给行为树的决策提供依据。 AI Perception: AI感知是actor component ，用于提供视觉，听觉，触觉等等感知，一般添加到AI Controller中 UE4行为树由事件驱动，可以通过条件装饰器观察数值，并且在可以中止其他节点。 AI 感知默认的AI Perception Component提供了视觉、听觉的配置，可视觉配置的属性如下，可以配置AI 可视半径，可视角度等一系列属性。 AI感知玩家并且设置黑板相关变量的简单例子： 如果需要定义特定的AI感知，可以继承UAISense类来实现特定感知。 服务节点服务节点是UE行为树的一种特殊功能，继承BTService_BlueprintBase，用于增加到Task节点或者复合节点，只要子节点在运行，服务节点就会以固定的频率tick，可以实现类似传统树的并行复合节点的功能，服务节点通过override Event Tick AI函数来实现特定的服务逻辑 场景查询系统（EQS）场景查询系统（EQS） 是UE4 AI系统的一个功能，可将其用于从环境中收集数据。在EQS中，可以通过不同种类的测试向收集的数据提问，这些测试会根据提出问题的类型来生成最适合的项目。 一次场景查询主要包括以下部分： 生成器（Generator），用于生成位置或actor，生成的东西被称为项目（item） 测试（Test），为所有的item打分（过滤），最终可以得到最佳的item 情景（Context），为各种测试和生成器提供引用，例如为距离测试提供一个衡量距离的Actor 生成器： Actors of Class 生成一定范围内的actor作为item Composite：合并多个生成器的结果 Points ：生成一定范围的点作为item Test：分为过滤测试（Filter）和评分（Socre）测试两类，过滤测试会移除未通过的item，评分测试会对所有的item评分，UE4中永远先进行过滤再进行评分。 UE中自带的测试包括距离测试、寻路测试、Trace测试等等，可以通过C++代码创建自定义测试。 Context：为生成器和测试提供指定Context，一般用于提供特定的点或者特定的Actor 在生成器类型的 Details 面板中，可以将查询器指定为下列属性的情境，例如在Points:Grid生成器中，生成中心默认是查询者Actor自身，也可以指定为一个Context的actor 新建一个Context： 创建 EnvQueryContext_BlueprintBase 类的新蓝图 override Provide Single Location或Provide Single Actor函数 EQS调试 单引号(‘)按键打开AI相关调试信息，默认是小键盘数字键1 2 3 4开关对应的调试信息，如果没有小键盘需要的project setting的gameplay debugger中修改按键 打开EQS调试，地面会标记当前EQS的查询结果，根据Environment Query规则给可选点进行打分，最终得到各个点的分值。 EQSTestPawn：可用于在编辑器中调试EQS查询结果，图中显示了特定点在周围的得分，该规则是过滤看不到右下角玩家的点，距离当前位置越近得分越高，该规则可以筛选出可以看到指定玩家最近的点。 用法： 创建EQSTestingPawn类型的蓝图 设置EQSTestingPawn的Query Template为指定的查询规则 AI 寻路导航区域类型设置Nav Modifier Volume可以在地图中为Cube指定区域的类型，默认的类型如下： Nav_null意味着不可走， Nav_Obstacle意味将指定相较于默认值 NavArea_Default更高的成本，寻路会尽可能避开该区域，除非代理找不到成本更低的路径。 可以通过继承Nav Area来实现自定的区域类型，修改默认成本（Default Cost） 乘数和 固定区域进入成本（Fixed Area Entering Cost）来实现自定义区域属性。 寻路查询筛选器（Navigation Query Filter）创建BP继承Navigation Query Filter，可以自定义所有导航区域的Cost，实现自定义导航路径的目的。 使用寻路查询筛选器的方式： 在Ai Controller 的Class Default设置默认的Filter 获取Controller，调用Move To函数 Navmesh生成的三种方式： Static， 寻路网格体离线生成，随关卡保存。寻路网格体在运行时加载，无法更改。 Dynamic，运行时动态生成，可以设置tick的时间 Dynamic Modifiers Only， 在运行时，只有寻路区域、寻路链接和动态对象之类的寻路修饰可以通过更改成本或阻挡区域来修改现有寻路网格体。在运行时不会生成新的寻路网格体表面。 以上生成方式可以在Project Setting或者recast中设置 Nav Modifier组件可以在运行时动态的修改NavMesh生成的网格，在Actor中添加Nav Modifier组件，可以设置Actor的区域类型， 不过运行修改的特性仅支持Dynamic Modifiers Only和Dynamic的网格生成方式。 设置（Settings） &gt; 项目设置（Project Settings），并转到 寻路系统（Navigation System） 类别。启用 仅在寻路调用程序周围生成寻路（Generate Navigation Only Around Navigation Invokers） 复选框，启用后配合动态生成方式可以仅在添加了Navigation Invoker的Actor的周围生成寻路网格，无需在编辑器中构建寻路网格，而是在运行时在代理周围生成寻路网格。 Nav Link Proxy功能是在两个点之间创建Navmesh可以识别的连接，可以用于AI通过障碍物等特定地形的导航。 Link类型： SimpleLink，可以识别到连接，但是Agent不一定能够通过，例如无法实现从下往上跳跃的过程 SmartLink，通过Event Receive SmartLink Reached来实现自定义AI速度、Play Montage等功能 SmartLink实现跳跃的例子： Link可以指定通过方向 可以结合NavArea 、NavQueryFilter，标记实现不同Nav Link的Enable Nav Area，只允许特定的Nav Area拥有该连接信息，然后通过NavQueryFilter指定包括或者排除特定Nav Area，在路径选择过程中指定NavFilter，可以实现不同AI有不同的导航地图，不同的跳跃能力 https://www.youtube.com/watch?v=5pMRqcRjC1k https://www.youtube.com/watch?v=ECys4U2fOKs&amp;list=PL4G2bSPE_8ukuajpXPlAE47Yez7EAyKMu&amp;index=12","categories":[],"tags":[{"name":"AI,UE","slug":"AI-UE","permalink":"http://nevermorec.gitee.io/tags/AI-UE/"}]},{"title":"Unity IK脚保持始终在地面","slug":"Unity IK脚保持始终在地面","date":"2021-12-11T13:39:30.000Z","updated":"2023-07-29T06:52:05.984Z","comments":true,"path":"2021/12/11/Unity IK脚保持始终在地面/","link":"","permalink":"http://nevermorec.gitee.io/2021/12/11/Unity%20IK%E8%84%9A%E4%BF%9D%E6%8C%81%E5%A7%8B%E7%BB%88%E5%9C%A8%E5%9C%B0%E9%9D%A2/","excerpt":"","text":"Unity时间函数执行顺序 上图是Unity中部分时间函数的执行顺序，大致是Update()、协程事件、动画事件、LateUpdate()，在使用IK过程中需要注意事件函数的更新顺序，不然修改的数据很可能无效。例如如果在Update中修改人体关节的位置，会因为动画事件的关节位置再次修改而导致之前的修改无效，所以更新人体关节的操作可以放在LateUpate中。 脚部IK的实现思路脚部IK主要控制角色脚的Position和Rotaion （1）通过射线检测计算左右脚离地距离、地面法线、地面位置 （2）判断脚是否接触地面（或者在地面以下），接触地面的脚需要使用地面法线、地面位置来修改脚部IK （3）如果是单脚接触地面的情况，需要下移臀部使得另一只脚也能够尽可能的在地面上 IK的位置需要在OnAnimatorIK中设置，臀部关节的设置需要在LateUpdate中； 为了避免脚趾穿模，可以增加一些射线检测来避免； 为了更好的移动效果，臀部关节的偏移可以加上插值 脚部IK的实现代码参考UTPM实现了一个脚步IK的功能 数据 123456789101112131415161718192021private Transform m_Transform;private Transform m_Hips;private Vector3 m_HipsLocalPosition;private float m_HipsOffset;float[] groundDistance = new float[2]; // 地面距离Vector3[] groundPoint = new Vector3[2]; // 地面接触点Vector3[] groundNormal = new Vector3[2]; // 射线检测法线[SerializeField] protected float m_HipsPositionAdjustmentSpeed = 4;private player m_Player;public FullBodyBipedIK ik;protected float m_FootOffsetAdjustment = 0.005f;private float[] m_LegLength = new float[2];private float[] m_FootOffset = new float[2];private int m_LayerMask; AnimatorIk 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697private void OnAnimatorIK(int layerIndex)&#123; HandleLowerIK();&#125;// Update is called once per frameprivate void HandleLowerIK()&#123; float hipsOffset = m_Player.c_ColliderSpacing; // 计算地面距离 for (int i = 0; i &lt; 2; i++) &#123; Vector3 legPos = (i == 0) ? ik.references.leftCalf.position : ik.references.rightCalf.position; Vector3 feetPos = (i == 0) ? ik.references.leftFoot.position : ik.references.rightFoot.position; var raycastStartPoint = GetFootRaycastPosition(feetPos, legPos); var m_RaycastHit = new RaycastHit(); if (Physics.Raycast(raycastStartPoint, -m_Transform.up, out m_RaycastHit, 2 * m_LegLength[i] + m_FootOffset[i] + m_FootOffsetAdjustment, m_LayerMask, QueryTriggerInteraction.Ignore)) &#123; groundDistance[i] = m_RaycastHit.distance; groundPoint[i] = m_RaycastHit.point; groundNormal[i] = m_RaycastHit.normal; UpdateHipsOffset(groundDistance[i], i, ref hipsOffset); &#125; else groundDistance[i] = float.MaxValue; Debug.DrawLine(raycastStartPoint, groundPoint[i]); &#125; // Smoothly position the hips. if (m_Player.CheckGround()) m_HipsOffset = Mathf.Lerp(m_HipsOffset, hipsOffset, m_HipsPositionAdjustmentSpeed * Time.deltaTime); else m_HipsOffset = Mathf.Lerp(m_HipsOffset, 0, m_HipsPositionAdjustmentSpeed * Time.deltaTime); m_HipsLocalPosition = m_Transform.InverseTransformPoint(m_Hips.position); m_HipsLocalPosition.y -= m_HipsOffset; HandleFootIK();&#125;// 计算地面检测的初始位置private Vector3 GetFootRaycastPosition(Vector3 feetPos, Vector3 legPos)&#123; var raycastPosition = m_Transform.InverseTransformPoint(feetPos); var localHipPosition = m_Transform.InverseTransformPoint(legPos); raycastPosition.y = localHipPosition.y; var result = m_Transform.TransformPoint(raycastPosition); return result;&#125;private void HandleFootIK()&#123; for (int i = 0; i &lt; 2; i++) &#123; // feet Vector3 legPos = (i == 0) ? ik.references.leftCalf.position : ik.references.rightCalf.position; var footTargetPos = (i == 0) ? ik.references.leftFoot.position : ik.references.rightFoot.position; var footTargetRot = (i == 0) ? ik.references.leftFoot.rotation : ik.references.rightFoot.rotation; var feetIKWeight = 0f; var effector = (i == 0) ? ik.solver.leftFootEffector : ik.solver.rightFootEffector; // 如果脚接触地面，使用脚步IK if (groundDistance[i] != float.MaxValue &amp;&amp; groundDistance[i] &gt; 0 &amp;&amp; m_Transform.InverseTransformDirection(footTargetPos - groundPoint[i]).y - m_FootOffset[i] - m_HipsOffset &lt; 0) &#123; var localFootTargetPos = m_Transform.InverseTransformPoint(footTargetPos); localFootTargetPos.y = m_Transform.InverseTransformPoint(groundPoint[i]).y; footTargetPos = m_Transform.TransformPoint(localFootTargetPos) + m_Transform.up * (m_FootOffset[i]); footTargetRot = Quaternion.LookRotation(Vector3.Cross(groundNormal[i], footTargetRot * -Vector3.right), m_Transform.up); //rotation = Quaternion.LookRotation(Vector3.Cross(m_GroundNormal[i], rotation * -Vector3.right), m_CharacterLocomotion.Up); feetIKWeight = 1f; &#125; effector.position = footTargetPos; effector.positionWeight = feetIKWeight; effector.rotation = footTargetRot; effector.rotationWeight = feetIKWeight; &#125;&#125;// 如果一只脚触地没设置臀部offset，使得另一只脚也能够触地private void UpdateHipsOffset(float groundDistance, int index, ref float hipsOffset)&#123; if (groundDistance != float.MaxValue) &#123; if ((groundDistance - m_LegLength[index] - m_FootOffset[index]) &gt; hipsOffset) &#123; hipsOffset = groundDistance - m_LegLength[index] - m_FootOffset[index]; &#125; &#125;&#125; LateUpdate 1234private void LateUpdate()&#123; m_Hips.position = m_Transform.TransformPoint(m_HipsLocalPosition);&#125;","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://nevermorec.gitee.io/tags/Unity/"}]},{"title":"AStarPathing学习笔记","slug":"AStarPathing学习笔记","date":"2021-11-02T13:39:30.000Z","updated":"2023-07-29T06:03:44.047Z","comments":true,"path":"2021/11/02/AStarPathing学习笔记/","link":"","permalink":"http://nevermorec.gitee.io/2021/11/02/AStarPathing%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"在寻路中使用动画的Root Motion直接使用AI Path、Rich AI等脚本控制移动存在的问题： 运动速度和动作不匹配，会出现滑步 角色的转向由AI Path直接控制，效果比较生硬 为了避免这些问题，可以使用RootMotion，将寻路的相关参数传入动画系统和设置相应的参数，通过动画来控制角色的位移。控制的示意图如下： ![](C:\\Users\\huangyuancheng\\Pictures\\屏幕截图 2021-11-17 142816.png) A* Pathingfinder Pro提供了MecanimBridge.cs脚本 以AI Path为例： （1）为角色挂载AI Path和MecanimBridge.cs脚本 （2）为角色添加Animator Controller，Animator Controller需要包含三个float参数（InputMagnitude、X左右的运动速度、Y前后的运动速度），MecanimBridge通过路径计算controller中的参数数据。 ![](C:\\Users\\huangyuancheng\\Pictures\\屏幕截图 2021-11-17 145845.png) MecanimBridge.cs脚本大致的实现思路： 关闭AI path中的自动更新位置和旋转 在OnAnimatorMove()中计算并设置动画参数，同时根据anim.deltaPosition和anim.deltaRotation更新角色移动和旋转 使用过程中存在的不足： 如果角速度过小会在尖角的特定地形卡住出不来，在实际过程中需要设置较大的角速度或者避免寻路到此点。 MecanimBridge.cs如果搭配AI path在角速度较小的情况下会直接直接穿过障碍物（穿模），使用Rich AI则不会。 使用Root motion控制位移相当于对路径再次进行处理，还和Animator动画进行关联，导致排查问题会更加困难。","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"http://nevermorec.gitee.io/tags/AI/"}]},{"title":"追踪子弹的实现","slug":"追踪子弹的实现","date":"2021-10-31T04:34:44.000Z","updated":"2021-10-31T04:47:38.082Z","comments":true,"path":"2021/10/31/追踪子弹的实现/","link":"","permalink":"http://nevermorec.gitee.io/2021/10/31/%E8%BF%BD%E8%B8%AA%E5%AD%90%E5%BC%B9%E7%9A%84%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"要实现一个BOSS可以发射追踪子弹，子弹可以自定义初始方向，需要在子弹运行过程中依据被追踪者的Position动态修改子弹的偏转方向。 实现思路： 计算当前距离的方向和子弹的方向的角度，依据转向速度动态修改子弹的rotation 关键参数： float RotSpeed; &#x2F;&#x2F; 转向速度 GameObject mEntity; &#x2F;&#x2F; 追踪Entity的当前Gameobject GameObject mTarget; &#x2F;&#x2F;被追踪者 实现代码： 12345678910111213Vector3 dir = (mTarget.transform.position + offset -mEntity.transform.position).normalized;float a = Vector3.Angle(mEntity.transform.forward, dir) / mRotSpeed;// rotate directionif (a &gt; 0.01f || a &lt; 0.01f)&#123; mEntity.transform.forward = Vector3.Slerp(mEntity.transform.forward, dir, fTick / a).normalized;&#125;float dv = mAcc * fTick;Displace = (mSpeed + 0.5f * dv) * fTick * mEntity.transform.forward;mSpeed += dv;","categories":[],"tags":[{"name":"Game Play","slug":"Game-Play","permalink":"http://nevermorec.gitee.io/tags/Game-Play/"}]},{"title":"在Unity上实现按钮点击（短按）和长按操作","slug":"在Unity上实现按钮点击（短按）和长按操作","date":"2021-08-29T02:15:52.000Z","updated":"2021-08-29T02:19:15.986Z","comments":true,"path":"2021/08/29/在Unity上实现按钮点击（短按）和长按操作/","link":"","permalink":"http://nevermorec.gitee.io/2021/08/29/%E5%9C%A8Unity%E4%B8%8A%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%92%AE%E7%82%B9%E5%87%BB%EF%BC%88%E7%9F%AD%E6%8C%89%EF%BC%89%E5%92%8C%E9%95%BF%E6%8C%89%E6%93%8D%E4%BD%9C/","excerpt":"","text":"在项目中需要完成长按技能显示技能详情的功能，由于Unity的Button只有Click时间，所以button不足以实现这个的功能。 实现方式：使用图片作为技能显示，通过继承MonoBehaviour,IPointerDownHandler,IPointerUpHandler,IPointerExitHandler接口来获取鼠标在Image上的操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/// &lt;summary&gt;/// 脚本位置：UGUI按钮组件身上/// 脚本功能：实现角色技能的短按（技能释放）/长按(显示技能详情)状态的判断/// &lt;/summary&gt; // 继承：按下，抬起和离开的三个接口public class OnSkillPressed :MonoBehaviour,IPointerDownHandler,IPointerUpHandler,IPointerExitHandler&#123; public int skillIndex; // 延迟时间 private float delay = 0.5f; // 技能图标是否是按下状态 private bool isDown = false; // 技能图标是否已经触发长按操作 private bool isLongPress = false; // 按钮最后一次是被按住状态时候的时间 private float lastIsDownTime; private GameMsg gameMsg = GameMsg.Instance; void Update () &#123; // 如果按钮是被按下状态 if (isDown &amp;&amp; (!isLongPress)) &#123; // 当前时间 - 按钮最后一次被按下的时间 &gt; 延迟时间0.2秒 if (Time.time - lastIsDownTime &gt; delay) &#123; // 触发长按方法 isLongPress = true; Debug.Log(&quot;长按技能： &quot; + skillIndex.ToString()); gameMsg.SendMessage(GameMsgType.LongPressSkill, skillIndex); // 记录按钮最后一次被按下的时间 // lastIsDownTime = Time.time; &#125; &#125; &#125; // 当按钮被按下后系统自动调用此方法 public void OnPointerDown (PointerEventData eventData) &#123; lastIsDownTime = Time.time; isDown = true; &#125; // 当按钮抬起的时候自动调用此方法 public void OnPointerUp (PointerEventData eventData) &#123; if (Time.time - lastIsDownTime &lt; delay) &#123; // Debug.Log(&quot;短按技能（显示技能范围）： &quot; + skillIndex.ToString()); gameMsg.SendMessage(GameMsgType.TapSkill, skillIndex); &#125; else &#123; gameMsg.SendMessage(GameMsgType.LongPressSkillCancel); &#125; isDown = false; isLongPress = false; &#125; // 当鼠标从按钮上离开的时候自动调用此方法 public void OnPointerExit (PointerEventData eventData) &#123; if (isLongPress) gameMsg.SendMessage(GameMsgType.LongPressSkillCancel); isDown = false; isLongPress = false; &#125;&#125;","categories":[],"tags":[]},{"title":"简单的UGUI闪烁脚本","slug":"简单的UGUI闪烁脚本","date":"2021-08-23T13:39:30.000Z","updated":"2023-07-29T05:43:40.576Z","comments":true,"path":"2021/08/23/简单的UGUI闪烁脚本/","link":"","permalink":"http://nevermorec.gitee.io/2021/08/23/%E7%AE%80%E5%8D%95%E7%9A%84UGUI%E9%97%AA%E7%83%81%E8%84%9A%E6%9C%AC/","excerpt":"","text":"场景：每次释放技能需要在确认前使得要消耗的行动点闪烁 实现思路：增加CanvasGroup，通过控制alpha值来实现闪烁 https://blog.csdn.net/qq_27489007/article/details/83745791 脚本 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667using UnityEngine;using System.Collections;using UnityEngine.UI;public class ShanShuoAnim : MonoBehaviour &#123; private float alpha = 0.2f; private float alphaSpeed = 8f; private bool isShow = true;//用来控制闪烁的内容 private CanvasGroup cg; private bool isClick = false;//用来控制 彻底不需要走动画了 private Image shanImg; public Sprite shan_sprite; //外部传进来的 void Start() &#123; cg = this.transform.GetComponent&lt;CanvasGroup&gt;(); shanImg = this.transform.GetComponent&lt;Image&gt;(); &#125; void Update() &#123; if (isClick) &#123; if (isShow) &#123; if (alpha != cg.alpha) &#123; cg.alpha = Mathf.Lerp(cg.alpha, alpha, alphaSpeed * Time.deltaTime); //这个方法表示的是一种简便过程 传入初始和想达到的 if (Mathf.Abs(alpha - cg.alpha) &lt;= 0.01) &#123; //Debug.Log(&quot;更新2===&quot; + alpha + &quot;===&quot; + cg.alpha); cg.alpha = alpha; isShow = false; &#125; &#125; &#125; else &#123; if (1 != cg.alpha) &#123; cg.alpha = Mathf.Lerp(cg.alpha, 1, alphaSpeed * Time.deltaTime); //这个方法表示的是一种简便过程 传入初始和想达到的 if (Mathf.Abs(1 - cg.alpha) &lt;= 0.01) &#123; //Debug.Log(&quot;更新3===&quot; + alpha + &quot;===&quot; + cg.alpha); cg.alpha = 1; isShow = true; &#125; &#125; &#125; &#125; &#125; public void ShowAnim() &#123; //alpha = 1; isClick = true; shanImg.sprite = shan_sprite; //cg.blocksRaycasts = true;//可以和该UI对象交互 &#125; public void HideAnim() &#123; isClick = false; //alpha = 0; //cg.blocksRaycasts = false;//不可以和该UI对象交互 &#125;&#125;","categories":[],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://nevermorec.gitee.io/tags/Unity/"}]}],"categories":[],"tags":[{"name":"AOI","slug":"AOI","permalink":"http://nevermorec.gitee.io/tags/AOI/"},{"name":"Unity","slug":"Unity","permalink":"http://nevermorec.gitee.io/tags/Unity/"},{"name":"Game101","slug":"Game101","permalink":"http://nevermorec.gitee.io/tags/Game101/"},{"name":"Game Play","slug":"Game-Play","permalink":"http://nevermorec.gitee.io/tags/Game-Play/"},{"name":"UE,GAMEPLAY","slug":"UE-GAMEPLAY","permalink":"http://nevermorec.gitee.io/tags/UE-GAMEPLAY/"},{"name":"AI,UE","slug":"AI-UE","permalink":"http://nevermorec.gitee.io/tags/AI-UE/"},{"name":"AI","slug":"AI","permalink":"http://nevermorec.gitee.io/tags/AI/"}]}